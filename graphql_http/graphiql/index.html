<!--
 *  Copyright (c) 2025 GraphQL Contributors
 *  All rights reserved.
 *
 *  This source code is licensed under the license found in the
 *  LICENSE file in the root directory of this source tree.
-->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GraphiQL</title>
    <style>
      body {
        margin: 0;
      }

      #graphiql {
        height: 100dvh;
      }

      .loading {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 4rem;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
    <link rel="stylesheet" href="https://esm.sh/graphiql/dist/style.css" />
    <link
      rel="stylesheet"
      href="https://esm.sh/@graphiql/plugin-explorer/dist/style.css"
    />
    <link
      rel="stylesheet"
      href="https://esm.sh/reactflow@11.10.4/dist/style.css"
    />
    <style>
      /* Custom GraphQL Schema Visualizer */
      .schema-visualizer {
        height: 100%;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
        background: #fafbfc;
        border-radius: 8px;
        overflow: hidden;
      }

      /* Ensure edges render behind nodes */
      .react-flow__edges {
        z-index: 1;
        transition: opacity 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }

      .react-flow__nodes {
        z-index: 2;
      }

      /* Smooth node position transitions - disabled to prevent blur/movement */
      .smooth-node-transition {
        /* transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) !important; */
      }

      /* Smooth edge transitions */
      .react-flow__edge {
        transition: opacity 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                    stroke 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
      }

      /* Fade animation classes */
      .edges-fading .react-flow__edges {
        opacity: 0.2;
      }

      .edges-fading .react-flow__edge {
        opacity: 0.3;
      }

      /* Style the bezier curves */
      .react-flow__edge-path {
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      .react-flow__edge.selected .react-flow__edge-path {
        stroke: #0366d6;
        stroke-width: 3;
      }

      /* Force edges to render behind everything */
      .react-flow__edge {
        z-index: -1 !important;
      }

      .react-flow__node {
        outline: 0px !important;
        z-index: 10 !important;
        background: transparent !important;
        box-shadow: none !important;
        border: none !important;
      }

      /* Hide nodes that have opacity 0 and visibility hidden */
      .react-flow__node[style*="opacity: 0"] {
        background: transparent !important;
        box-shadow: none !important;
        border: none !important;
      }

      /* Hide ReactFlow attribution text only */
      .react-flow__attribution {
        display: none !important;
      }

      /* Remove CSS transitions - React Flow handles animations internally */

      /* Style the control buttons */
      .react-flow__controls button {
        transition: all 0.2s ease;
      }

      .react-flow__controls button:hover {
        transform: scale(1.1);
      }
    </style>
    <!-- React Flow CSS removed - using custom styles -->
    <!--
     * Note:
     * The ?standalone flag bundles the module along with all of its `dependencies`, excluding `peerDependencies`, into a single JavaScript file.
     * `@emotion/is-prop-valid` is a shim to remove the console error ` module "@emotion /is-prop-valid" not found`. Upstream issue: https://github.com/motiondivision/motion/issues/3126
    -->
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@19.1.0",
          "react/": "https://esm.sh/react@19.1.0/",

          "react-dom": "https://esm.sh/react-dom@19.1.0",
          "react-dom/": "https://esm.sh/react-dom@19.1.0/",

          "graphiql": "https://esm.sh/graphiql?standalone&external=react,react-dom,@graphiql/react,graphql",
          "graphiql/": "https://esm.sh/graphiql/",
          "@graphiql/plugin-explorer": "https://esm.sh/@graphiql/plugin-explorer?standalone&external=react,@graphiql/react,graphql",
          "@graphiql/react": "https://esm.sh/@graphiql/react?standalone&external=react,react-dom,graphql,@graphiql/toolkit,@emotion/is-prop-valid",

          "@graphiql/toolkit": "https://esm.sh/@graphiql/toolkit?standalone&external=graphql",
          "graphql": "https://esm.sh/graphql@16.11.0",
          "@emotion/is-prop-valid": "data:text/javascript,",
          "reactflow": "https://esm.sh/reactflow@11.10.4?external=react,react-dom",
          "elkjs": "https://esm.sh/elkjs@0.8.2"
        }
      }
    </script>
    <script type="module">
      import React from 'react';
      import ReactDOM from 'react-dom/client';
      import { GraphiQL, HISTORY_PLUGIN } from 'graphiql';
      import { createGraphiQLFetcher } from '@graphiql/toolkit';
      import { explorerPlugin } from '@graphiql/plugin-explorer';
      import { useEditorContext, usePluginContext, ToolbarButton } from '@graphiql/react';
      import { buildClientSchema, printSchema, getIntrospectionQuery } from 'graphql';
      import 'graphiql/setup-workers/esm.sh';
      import ReactFlow, {
        Controls,
        MiniMap,
        Background,
        useNodesState,
        useEdgesState,
        addEdge,
        useReactFlow
      } from 'reactflow';
      import ELK from 'elkjs';

      // Environment-injected Gemini API key (set via GRAPHIQL_GEMINI_API_KEY env var)
      // Server replaces __GEMINI_API_KEY__ with env value or empty string
      const ENV_GEMINI_API_KEY = '__GEMINI_API_KEY__';

      // Helper to get API key - uses localStorage first, falls back to env key silently
      const getGeminiApiKey = () => {
        const stored = localStorage.getItem('graphiql:gemini-api-key');
        if (stored) return stored;
        if (ENV_GEMINI_API_KEY) {
          return ENV_GEMINI_API_KEY;
        }
        return '';
      };

      // Custom Graph Node - contains our entire graph visualization
      const GraphVisualizationNode = ({ data }) => {
        const { getViewport, fitBounds, setViewport, zoomIn, zoomOut } = useReactFlow();
        const reactFlowViewport = getViewport();

        const centerOnRootTypes = React.useCallback(() => {
          if (typeof fitBounds !== 'function' || typeof setViewport !== 'function') {
            return;
          }

          // Mark that we're now in root types view
          window._isRootTypesView = true;

          const currentNodes = window._cachedLayoutData?.nodes || window._lastELKLayoutData?.nodes || [];

          const rootTypeNodes = currentNodes.filter(node =>
            !node.data?.hidden &&
            node.position &&
            (node.data?.isQueryType || node.data?.isMutationType || node.data?.isSubscriptionType)
          );

          if (rootTypeNodes.length === 0) {
            return;
          }

          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

          // Calculate bounds around all root type nodes
          rootTypeNodes.forEach(node => {
            const x = node.position.x;
            const y = node.position.y;

            // Try to get measured dimensions, fallback to defaults
            let width = 300, height = 200;
            if (window.measuredNodeDimensions && window.measuredNodeDimensions.has(node.id)) {
              const measured = window.measuredNodeDimensions.get(node.id);
              width = measured.width;
              height = measured.height;
            }

            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x + width);
            maxY = Math.max(maxY, y + height);
          });

          if (minX === Infinity) {
            return;
          }

          const rootBounds = {
            x: minX - 50,
            y: minY - 80, // Extra top padding to prevent cutoff
            width: maxX - minX + 100,
            height: maxY - minY + 130 // Compensate for extra top padding
          };

          try {
            fitBounds(rootBounds, { duration: 800, padding: 0.15 });
          } catch (error) {

            // Manual viewport calculation as fallback
            const containerWidth = 1000;
            const containerHeight = 800;

            const scaleX = containerWidth / (rootBounds.width + 100);
            const scaleY = containerHeight / (rootBounds.height + 100);
            const scale = Math.min(scaleX, scaleY, 1.5); // Cap at 1.5x zoom

            const x = -(rootBounds.x + rootBounds.width / 2) * scale + containerWidth / 2;
            const y = -(rootBounds.y + rootBounds.height / 2) * scale + containerHeight / 2;

            setViewport({ x, y, zoom: scale }, { duration: 600 });
          }
        }, [fitBounds, setViewport]);

        React.useEffect(() => {
          window._centerOnRootTypes = centerOnRootTypes;
          return () => {
            delete window._centerOnRootTypes;
          };
        }, [centerOnRootTypes]);

        // Handle focus bounds changes for double-click navigation
        React.useEffect(() => {
          const checkFocusBounds = () => {
            if (window._focusBounds) {
              const bounds = window._focusBounds;

              // Try both approaches - fitBounds and manual viewport calculation
              try {
                fitBounds(bounds, { duration: 800, padding: 0.08 });
              } catch (error) {
                // Manual viewport calculation as fallback
                const containerWidth = 1000; // Approximate viewport width
                const containerHeight = 800; // Approximate viewport height

                const scaleX = containerWidth / bounds.width;
                const scaleY = containerHeight / bounds.height;
                const scale = Math.min(scaleX, scaleY, 1.5); // Max zoom of 1.5x

                const x = -(bounds.x * scale) + (containerWidth - bounds.width * scale) / 2;
                const y = -(bounds.y * scale) + (containerHeight - bounds.height * scale) / 2;

                setViewport({ x, y, zoom: scale }, { duration: 400 }); // Faster fit view
              }

              // Clear the bounds after applying (but keep debug info)
              delete window._focusBounds;

              // Keep _lastFocusBounds for debug visualization - don't auto-clear
            }
          };

          // Check immediately and set up interval
          checkFocusBounds();
          const interval = setInterval(checkFocusBounds, 100);

          return () => clearInterval(interval);
        }, [fitBounds, setViewport]);

        // Initial fit view on component mount - wait for ELK layout data
        React.useEffect(() => {
          // Always start with loading screen to hide any initial movement
          setGraphVisible(false);

          // Check if this is the very first load of the visualization
          const isFirstLoad = !window._graphVisualizationEverLoaded;

          if (isFirstLoad) {
            // First time ever - do initial fit view
            window._graphVisualizationEverLoaded = true;
            window._initialFitViewDone = false;
          } else {
            // Returning to tab - shorter delay since no layout calculation needed
            setTimeout(() => {
              setGraphVisible(true);
            }, 100); // Shorter delay when restoring
            return; // Skip the fit view logic
          }


          // Poll for ELK layout data to be available
          const checkForELKData = () => {
            if (window._lastELKLayoutData && window._lastELKLayoutData.nodes && window._lastELKLayoutData.nodes.length > 0) {
              console.log('ELK data available, running initial fit view');
              window._initialFitViewDone = true;

              if (window._smoothFitView) {
                window._smoothFitView();
                // Show the graph after fit view completes, then center on root types
                setTimeout(() => {
                  setGraphVisible(true);
                  // Auto-center on root types after initial load
                  setTimeout(() => {
                    if (window._centerOnRootTypes) {
                      window._centerOnRootTypes();
                    }
                  }, 800); // Delay to let the graph become visible first
                }, 500); // Small delay to let fit view complete
              } else {
                setGraphVisible(true); // Show anyway if fit view isn't available
                // Auto-center on root types after initial load (fallback)
                setTimeout(() => {
                  if (window._centerOnRootTypes) {
                    window._centerOnRootTypes();
                  }
                }, 800); // Delay to let the graph become visible first
              }
            } else {
              console.log('ELK data not ready yet, will check again...');
              setTimeout(checkForELKData, 100); // Check again in 100ms - faster polling
            }
          };

          // Start checking after a short delay to let ELK run
          setTimeout(checkForELKData, 300); // Faster initial check
        }, []); // Only run once on mount

        // Set up smooth zoom handlers using React Flow's built-in animations
        React.useEffect(() => {
          // Override default zoom behavior with React Flow's smooth transitions
          window._smoothZoomIn = () => {
            const current = getViewport();
            const newZoom = Math.min(2, current.zoom * 1.5);

            // Get actual container dimensions
            const container = document.querySelector('.react-flow');
            const containerWidth = container ? container.clientWidth : 1000;
            const containerHeight = container ? container.clientHeight : 800;
            const centerX = containerWidth / 2;
            const centerY = containerHeight / 2;

            // Calculate world coordinates of center point
            const worldCenterX = (centerX - current.x) / current.zoom;
            const worldCenterY = (centerY - current.y) / current.zoom;

            // Calculate new position to keep center point in same place after zoom
            const newX = centerX - (worldCenterX * newZoom);
            const newY = centerY - (worldCenterY * newZoom);

            setViewport({ x: newX, y: newY, zoom: newZoom }, { duration: 200 }); // Faster zoom
          };

          window._smoothZoomOut = () => {
            const current = getViewport();
            const newZoom = Math.max(0.1, current.zoom / 1.5);

            // Get actual container dimensions
            const container = document.querySelector('.react-flow');
            const containerWidth = container ? container.clientWidth : 1000;
            const containerHeight = container ? container.clientHeight : 800;
            const centerX = containerWidth / 2;
            const centerY = containerHeight / 2;

            // Calculate world coordinates of center point
            const worldCenterX = (centerX - current.x) / current.zoom;
            const worldCenterY = (centerY - current.y) / current.zoom;

            // Calculate new position to keep center point in same place after zoom
            const newX = centerX - (worldCenterX * newZoom);
            const newY = centerY - (worldCenterY * newZoom);

            setViewport({ x: newX, y: newY, zoom: newZoom }, { duration: 200 }); // Faster zoom
          };

          // Store reference to get latest ELK layout data
          window._getLatestLayoutData = () => {
            // Look for the most recent ELK layout data stored globally
            if (window._lastELKLayoutData) {
              return window._lastELKLayoutData;
            }
            return null;
          };

          window._smoothFitView = () => {
            console.log('Smooth Fit View called');

            // Mark that we're now in full view
            window._isRootTypesView = false;

            // Use stored ELK layout data if available
            const layoutData = window._getLatestLayoutData();

            if (!layoutData || !layoutData.nodes || layoutData.nodes.length === 0) {
              console.log('No ELK layout data available for fit view');
              return;
            }

            console.log('Using ELK layout data with', layoutData.nodes.length, 'nodes');

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            // Use the ELK-calculated positions directly
            layoutData.nodes.forEach(node => {
              if (node.position && !node.data?.hidden) {
                const x = node.position.x;
                const y = node.position.y;

                // Get measured dimensions or use reasonable defaults
                let width = 280, height = 200;
                if (window.measuredNodeDimensions && window.measuredNodeDimensions.has(node.id)) {
                  const measured = window.measuredNodeDimensions.get(node.id);
                  width = measured.width;
                  height = measured.height;
                }

                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x + width);
                maxY = Math.max(maxY, y + height);

                console.log(`ELK Node ${node.id}: (${x}, ${y}) ${width}x${height}`);
              }
            });

            if (minX === Infinity) {
              console.log('No valid ELK bounds calculated');
              return;
            }

            const bounds = {
              x: minX - 50,
              y: minY - 50,
              width: maxX - minX + 100,
              height: maxY - minY + 100
            };

            console.log('Calculated ELK bounds for fit view:', bounds);

            // Add extra top padding to prevent cutoff
            bounds.y -= 30; // Extra 30px top padding
            bounds.height += 30; // Compensate height

            // Calculate viewport manually for reliable results
            const container = document.querySelector('.react-flow');
            const containerWidth = container ? container.clientWidth : 1000;
            const containerHeight = container ? container.clientHeight : 800;

            console.log('Container dimensions:', { containerWidth, containerHeight });

            // Calculate scale to fit the bounds with padding
            // Account for container padding and ensure we don't touch the edges
            const paddingFactor = 0.85; // 15% padding to account for container margins
            const scaleX = (containerWidth * paddingFactor) / bounds.width;
            const scaleY = (containerHeight * paddingFactor) / bounds.height;
            const scale = Math.min(scaleX, scaleY, 1.5); // Cap at 1.5x zoom

            // Calculate position to center the bounds
            const x = (containerWidth - bounds.width * scale) / 2 - bounds.x * scale;
            const y = (containerHeight - bounds.height * scale) / 2 - bounds.y * scale;

            console.log('Calculated viewport:', {
              x: x.toFixed(1),
              y: y.toFixed(1),
              zoom: scale.toFixed(3),
              bounds,
              scaleX: scaleX.toFixed(3),
              scaleY: scaleY.toFixed(3)
            });

            setViewport({ x, y, zoom: scale }, { duration: 400 }); // Faster fit view
          };

          return () => {
            delete window._smoothZoomIn;
            delete window._smoothZoomOut;
            delete window._smoothFitView;
            delete window._getLatestLayoutData;
          };
        }, [getViewport, setViewport, fitBounds]);

        // Persist viewport when it changes
        React.useEffect(() => {
          const interval = setInterval(() => {
            const currentViewport = getViewport();
            window._persistedViewport = currentViewport;
          }, 1000); // Save viewport every second

          return () => clearInterval(interval);
        }, [getViewport]);

        // Restore viewport on mount if returning to tab
        React.useEffect(() => {
          if (window._persistedViewport && window._graphVisualizationEverLoaded) {
            setTimeout(() => {
              setViewport(window._persistedViewport, { duration: 0 });
            }, 50); // Small delay to ensure component is ready
          }
        }, [setViewport]);

        const {
          nodes,
          edges,
          selectedNodeId,
          setSelectedNodeId,
          onNodeClick,
          onNodeDoubleClick,
          showELKDebug,
          elkDebugData,
          edgesFading,
          setGraphVisible
        } = data;

        // Create a dynamic bounding box calculator that accesses current data
        const createBoundingBoxCalculator = () => {
          return () => {
            // Access current data from the component's scope
            const currentNodes = data.nodes || [];
            const currentEdges = data.edges || [];

            const visibleNodes = currentNodes.filter(node => !node.data?.hidden && node.position);
            const visibleEdges = currentEdges.filter(edge => !edge.data?.hidden);


            if (visibleNodes.length === 0) {
              return null;
            }

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            // Include all visible nodes
            visibleNodes.forEach(node => {
              const x = node.position.x;
              const y = node.position.y;

              // Try to get measured dimensions, fallback to defaults
              let width = 200, height = 100;
              if (window.measuredNodeDimensions && window.measuredNodeDimensions.has(node.id)) {
                const measured = window.measuredNodeDimensions.get(node.id);
                width = measured.width;
                height = measured.height;
              }

              minX = Math.min(minX, x);
              minY = Math.min(minY, y);
              maxX = Math.max(maxX, x + width);
              maxY = Math.max(maxY, y + height);
            });

            // Include all edge path points to ensure edges are within bounds
            visibleEdges.forEach(edge => {
              if (edge.data?.pathData) {
                // Parse SVG path data to get all coordinates
                const pathData = edge.data.pathData;
                const coordinates = pathData.match(/[\d.-]+/g);

                if (coordinates) {
                  for (let i = 0; i < coordinates.length; i += 2) {
                    const x = parseFloat(coordinates[i]);
                    const y = parseFloat(coordinates[i + 1]);

                    if (!isNaN(x) && !isNaN(y)) {
                      minX = Math.min(minX, x);
                      minY = Math.min(minY, y);
                      maxX = Math.max(maxX, x);
                      maxY = Math.max(maxY, y);
                    }
                  }
                }
              }
            });

            if (minX === Infinity) {
              return null;
            }

            const bounds = {
              x: minX - 50,
              y: minY - 80, // Extra top padding to prevent cutoff
              width: maxX - minX + 100,
              height: maxY - minY + 130 // Compensate for extra top padding
            };

            return bounds;
          };
        };

        const calculateBoundingBox = createBoundingBoxCalculator();

        const boundingBox = calculateBoundingBox();

        // Create a bounding box calculator specifically for root types
        const createRootTypesBoundingBoxCalculator = () => {
          return () => {
            const currentNodes = data.nodes || [];

            // Find root type nodes (Query, Mutation, Subscription)
            const rootTypeNodes = currentNodes.filter(node =>
              !node.data?.hidden &&
              node.position &&
              (node.data?.isQueryType || node.data?.isMutationType || node.data?.isSubscriptionType)
            );


            if (rootTypeNodes.length === 0) {
              return null;
            }

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            // Calculate bounds around all root type nodes
            rootTypeNodes.forEach(node => {
              const x = node.position.x;
              const y = node.position.y;

              // Try to get measured dimensions, fallback to defaults
              let width = 300, height = 200;
              if (window.measuredNodeDimensions && window.measuredNodeDimensions.has(node.id)) {
                const measured = window.measuredNodeDimensions.get(node.id);
                width = measured.width;
                height = measured.height;
              }

              minX = Math.min(minX, x);
              minY = Math.min(minY, y);
              maxX = Math.max(maxX, x + width);
              maxY = Math.max(maxY, y + height);
            });

            if (minX === Infinity) {
              return null;
            }

            const bounds = {
              x: minX - 50,
              y: minY - 50,
              width: maxX - minX + 100,
              height: maxY - minY + 100
            };

            return bounds;
          };
        };

        const calculateRootTypesBoundingBox = createRootTypesBoundingBoxCalculator();
        const rootTypesBoundingBox = calculateRootTypesBoundingBox();

        // Calculate the bounding box of all nodes and edges to size the container appropriately
        const calculateBounds = () => {
          if (!nodes || nodes.length === 0) return { width: 1000, height: 800 };

          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

          // Include all visible nodes
          nodes.forEach(node => {
            if (!node.data?.hidden && node.position) {
              // Try to get actual measured dimensions, otherwise use reasonable estimates
              let nodeWidth = 350;
              let nodeHeight = 200;

              if (window.measuredNodeDimensions && window.measuredNodeDimensions.has(node.id)) {
                const measured = window.measuredNodeDimensions.get(node.id);
                nodeWidth = measured.width;
                nodeHeight = measured.height;
              }

              minX = Math.min(minX, node.position.x);
              minY = Math.min(minY, node.position.y);
              maxX = Math.max(maxX, node.position.x + nodeWidth);
              maxY = Math.max(maxY, node.position.y + nodeHeight);
            }
          });

          // Include all edge path points to ensure edges are within bounds
          edges.forEach(edge => {
            if (!edge.data?.hidden && edge.data?.pathData) {
              // Parse SVG path data to get all coordinates
              const pathData = edge.data.pathData;
              const coordinates = pathData.match(/[\d.-]+/g);

              if (coordinates) {
                for (let i = 0; i < coordinates.length; i += 2) {
                  const x = parseFloat(coordinates[i]);
                  const y = parseFloat(coordinates[i + 1]);

                  if (!isNaN(x) && !isNaN(y)) {
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                  }
                }
              }
            }
          });

          // Add padding around the content
          const padding = 100;
          return {
            width: Math.max(1000, maxX - minX + padding),
            height: Math.max(800, maxY - minY + padding)
          };
        };

        const bounds = calculateBounds();

        return React.createElement('div', {
          style: {
            width: `${bounds.width}px`,
            height: `${bounds.height}px`,
            position: 'relative',
            background: 'transparent',
            pointerEvents: 'auto'
          },
          onClick: (e) => {
            // Only deselect if clicking on the container background (not on a node)
            if (e.target === e.currentTarget) {
              setSelectedNodeId(null);
            }
          }
        }, [
          // SVG for edges
          React.createElement('svg', {
            key: 'edges-svg',
            style: {
              position: 'absolute',
              left: 0,
              top: 0,
              width: '100%',
              height: '100%',
              pointerEvents: 'none',
              zIndex: 1
            }
          }, [
            // Circle marker definitions
            React.createElement('defs', { key: 'defs' }, [
              React.createElement('marker', {
                key: 'circleEnd',
                id: 'circleEnd',
                markerWidth: 8,
                markerHeight: 8,
                refX: 4,
                refY: 4,
                orient: 'auto',
                markerUnits: 'strokeWidth'
              }, [
                React.createElement('circle', {
                  key: 'circle-marker',
                  cx: 4,
                  cy: 4,
                  r: 3,
                  fill: '#d0d0d0',
                  stroke: '#d0d0d0',
                  strokeWidth: 1
                })
              ]),
              React.createElement('marker', {
                key: 'circleEndHighlight',
                id: 'circleEndHighlight',
                markerWidth: 8,
                markerHeight: 8,
                refX: 4,
                refY: 4,
                orient: 'auto',
                markerUnits: 'strokeWidth'
              }, [
                React.createElement('circle', {
                  key: 'circle-marker-highlight',
                  cx: 4,
                  cy: 4,
                  r: 3,
                  fill: '#0366d6',
                  stroke: '#0366d6',
                  strokeWidth: 1
                })
              ])
            ]),
            // Render edges as SVG paths
            ...edges.filter(edge => !edge.data?.hidden).map(edge => {
              if (!edge.data?.pathData) return null;

              // Check if this edge is descended from the selected node (outgoing only)
              const isHighlighted = selectedNodeId && edge.source === selectedNodeId;
              const isArgumentEdge = edge.data?.isArgumentEdge;

              // Different styling for argument edges - less prominent even when highlighted
              if (isArgumentEdge) {
                const isArgHighlighted = selectedNodeId && edge.source === selectedNodeId;
                return React.createElement('path', {
                  key: edge.id,
                  d: edge.data.pathData,
                  stroke: isArgHighlighted ? '#0366d6' : '#9ca3af', // Blue when highlighted, grey otherwise
                  strokeWidth: isArgHighlighted ? 2 : 1, // Thicker when highlighted but not as thick as regular edges
                  strokeDasharray: '3,3', // Always dashed
                  fill: 'none',
                  markerEnd: isArgHighlighted ? 'url(#circleEndHighlight)' : 'url(#circleEnd)',
                  opacity: edgesFading ? 0.3 : (selectedNodeId && !isArgHighlighted ? 0.3 : isArgHighlighted ? 0.8 : 0.6), // More visible than before
                  style: {
                    transition: 'all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                  }
                });
              }

              return React.createElement('path', {
                key: edge.id,
                d: edge.data.pathData,
                stroke: isHighlighted ? '#0366d6' : '#d0d0d0',
                strokeWidth: isHighlighted ? 5 : 2,
                fill: 'none',
                markerEnd: isHighlighted ? 'url(#circleEndHighlight)' : 'url(#circleEnd)',
                opacity: edgesFading ? 0.3 : (selectedNodeId && !isHighlighted ? 0.2 : 1),
                style: {
                  transition: 'all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                }
              });
            })
          ]),

          // Render nodes as positioned DOM elements
          ...nodes.filter(node => !node.data?.hidden).map(node =>
            React.createElement('div', {
              key: node.id,
              'data-node-id': node.id,
              onClick: (e) => {
                e.stopPropagation();
                onNodeClick(null, node);
              },
              // Double-click now handled by individual GraphQLTypeNode components
              style: {
                position: 'absolute',
                left: `${node.position.x}px`,
                top: `${node.position.y}px`,
                zIndex: 2,
                cursor: 'pointer'
              }
            }, [
              // Render the node content directly
              GraphQLTypeNode({
                data: {
                  ...node.data,
                  nodeId: node.id,
                  isSelected: selectedNodeId === node.id,
                  reactFlowViewport: reactFlowViewport
                }
              })
            ])
          ),

          // ELK Debug overlay
          showELKDebug && elkDebugData && React.createElement('svg', {
            key: 'elk-debug-svg',
            style: {
              position: 'absolute',
              left: 0,
              top: 0,
              width: '100%',
              height: '100%',
              pointerEvents: 'none',
              zIndex: 1000,
              opacity: 0.5
            }
          }, [
            // Draw ELK-proposed node positions
            ...(elkDebugData.children || []).map(elkNode => [
              // Node rectangle - using actual ELK dimensions
              React.createElement('rect', {
                key: `elk-${elkNode.id}`,
                x: elkNode.x,
                y: elkNode.y,
                width: elkNode.width,
                height: elkNode.height,
                fill: 'none',
                stroke: '#ff0000',
                strokeWidth: 2,
                strokeDasharray: '5,5',
                opacity: 0.8
              }),
              // Node label
              React.createElement('text', {
                key: `elk-label-${elkNode.id}`,
                x: elkNode.x + 5,
                y: elkNode.y - 5,
                fontSize: '12px',
                fill: '#ff0000',
                fontWeight: 'bold',
                fontFamily: 'monospace'
              }, `ELK: ${elkNode.id}`),
              // Draw ELK-proposed port positions
              ...(elkNode.ports || []).map(port =>
                React.createElement('circle', {
                  key: `elk-port-${elkNode.id}-${port.id}`,
                  cx: elkNode.x + port.x,
                  cy: elkNode.y + port.y,
                  r: 3,
                  fill: port.isRelationship ? '#ff6600' :
                        port.isScalar ? '#9966ff' :
                        port.id.includes('target') ? '#0066ff' : '#cccccc',
                  stroke: '#000',
                  strokeWidth: 1
                })
              )
            ]).flat(),

            // Draw ELK edges
            ...(elkDebugData.edges || []).map(elkEdge => {
              if (!elkEdge.sections || elkEdge.sections.length === 0) return null;
              const section = elkEdge.sections[0];
              let pathData = `M ${section.startPoint.x} ${section.startPoint.y}`;

              if (section.bendPoints && section.bendPoints.length > 0) {
                section.bendPoints.forEach(point => {
                  pathData += ` L ${point.x} ${point.y}`;
                });
              }
              pathData += ` L ${section.endPoint.x} ${section.endPoint.y}`;

              return React.createElement('path', {
                key: `elk-edge-${elkEdge.id}`,
                d: pathData,
                stroke: '#00ff00',
                strokeWidth: 2,
                strokeDasharray: '5,5',
                fill: 'none',
                opacity: 0.8
              });
            }),

            // Focus Bounds Visualization - shows the area that double-click will target
            window._lastFocusBounds && React.createElement('rect', {
              key: 'focus-bounds-debug',
              x: window._lastFocusBounds.x,
              y: window._lastFocusBounds.y,
              width: window._lastFocusBounds.width,
              height: window._lastFocusBounds.height,
              fill: 'none',
              stroke: '#ff8800',
              strokeWidth: 3,
              strokeDasharray: '10,5',
              opacity: 0.9
            }),

            // Focus Bounds Label
            window._lastFocusBounds && React.createElement('text', {
              key: 'focus-bounds-label',
              x: window._lastFocusBounds.x + 10,
              y: window._lastFocusBounds.y - 10,
              fontSize: '14px',
              fill: '#ff8800',
              fontWeight: 'bold',
              fontFamily: 'monospace'
            }, `FOCUS: ${Math.round(window._lastFocusBounds.width)}Ã—${Math.round(window._lastFocusBounds.height)}`)
          ]),

          // Bounding Box Visualization - shows the area that fit view will target
          boundingBox && showELKDebug && React.createElement('div', {
            key: 'bounding-box-overlay',
            style: {
              position: 'absolute',
              left: `${boundingBox.x}px`,
              top: `${boundingBox.y}px`,
              width: `${boundingBox.width}px`,
              height: `${boundingBox.height}px`,
              border: '3px dashed #ff0080',
              borderRadius: '8px',
              backgroundColor: 'rgba(255, 0, 128, 0.01)', // 10x more transparent
              pointerEvents: 'none',
              zIndex: 1001,
              boxSizing: 'border-box'
            }
          }),

          // Bounding Box Label
          boundingBox && showELKDebug && React.createElement('div', {
            key: 'bounding-box-label',
            style: {
              position: 'absolute',
              left: `${boundingBox.x + 10}px`,
              top: `${boundingBox.y - 25}px`,
              background: 'rgba(255, 0, 128, 0.9)',
              color: 'white',
              padding: '4px 8px',
              borderRadius: '4px',
              fontSize: '12px',
              fontFamily: 'monospace',
              fontWeight: 'bold',
              pointerEvents: 'none',
              zIndex: 1002
            }
          }, `FIT VIEW BOUNDS: ${Math.round(boundingBox.width)}Ã—${Math.round(boundingBox.height)}`),

          // Root Types Bounding Box Visualization
          rootTypesBoundingBox && showELKDebug && React.createElement('div', {
            key: 'root-types-bounding-box-overlay',
            style: {
              position: 'absolute',
              left: `${rootTypesBoundingBox.x}px`,
              top: `${rootTypesBoundingBox.y}px`,
              width: `${rootTypesBoundingBox.width}px`,
              height: `${rootTypesBoundingBox.height}px`,
              border: '3px dashed #00ff80',
              borderRadius: '8px',
              backgroundColor: 'rgba(0, 255, 128, 0.05)',
              pointerEvents: 'none',
              zIndex: 1001,
              boxSizing: 'border-box'
            }
          }),

          // Root Types Bounding Box Label
          rootTypesBoundingBox && showELKDebug && React.createElement('div', {
            key: 'root-types-bounding-box-label',
            style: {
              position: 'absolute',
              left: `${rootTypesBoundingBox.x + 10}px`,
              top: `${rootTypesBoundingBox.y - 25}px`,
              background: 'rgba(0, 255, 128, 0.9)',
              color: 'white',
              padding: '4px 8px',
              borderRadius: '4px',
              fontSize: '12px',
              fontFamily: 'monospace',
              fontWeight: 'bold',
              pointerEvents: 'none',
              zIndex: 1002
            }
          }, `ROOT TYPES: ${Math.round(rootTypesBoundingBox.width)}Ã—${Math.round(rootTypesBoundingBox.height)}`)
        ]);
      };

      // Define custom node types
      const nodeTypes = {
        graphVisualization: GraphVisualizationNode
      };

      // SDL Download Plugin
      const sdlDownloadPlugin = {
        title: 'SDL Download',
        icon: () => React.createElement('svg', {
          width: '16',
          height: '16',
          viewBox: '0 0 24 24',
          fill: 'currentColor'
        }, React.createElement('path', {
          d: 'M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z'
        })),
        content: () => {
          const [sdlContent, setSdlContent] = React.useState('');
          const [loading, setLoading] = React.useState(false);
          const [error, setError] = React.useState(null);

          const generateSDL = async () => {
            setLoading(true);
            setError(null);
            try {
              const introspectionQuery = getIntrospectionQuery();

              const result = await fetcher({
                query: introspectionQuery,
                operationName: 'IntrospectionQuery'
              });

              if (result.errors) {
                throw new Error(result.errors[0].message);
              }

              const schema = buildClientSchema(result.data);
              const sdl = printSchema(schema);
              setSdlContent(sdl);
            } catch (err) {
              setError(err.message);
            } finally {
              setLoading(false);
            }
          };

          React.useEffect(() => {
            generateSDL();
          }, []);

          return React.createElement('div', {
            style: {
              padding: '0px',
              height: '100%',
              display: 'flex',
              flexDirection: 'column',
              gap: '16px'
            }
          }, [
            React.createElement('h3', {
              key: 'title',
              style: {
                margin: '0 0 4px 0',
                fontSize: '29px',
                fontWeight: 'bold'
              }
            }, 'Schema Download'),
            React.createElement('p', {
              key: 'description',
              className: 'graphiql-markdown-description',
              style: {
                margin: '0 0 20px 0',
                color: 'rgba(59, 75, 104, 0.76)'
              }
            }, 'Download your GraphQL schema as SDL (Schema Definition Language).'),

            // Schema Preview Section
            React.createElement('div', {
              key: 'preview-section',
              style: {
                flex: 1,
                display: 'flex',
                flexDirection: 'column',
                minHeight: 0
              }
            }, [
              React.createElement('div', {
                key: 'preview-header',
                style: {
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  marginBottom: '8px'
                }
              }, [
                React.createElement('span', {
                  key: 'file-icon',
                  style: {
                    fontSize: '14px'
                  }
                }, 'ðŸ“„'),
                React.createElement('span', {
                  key: 'filename',
                  style: {
                    fontSize: '13px',
                    fontWeight: '600',
                    color: '#24292e'
                  }
                }, 'schema.graphql'),
                React.createElement('span', {
                  key: 'preview-label',
                  style: {
                    fontSize: '11px',
                    color: '#586069',
                    fontStyle: 'italic'
                  }
                }, '(preview)')
              ]),

              loading ? React.createElement('div', {
                key: 'loading-preview',
                style: {
                  flex: 1,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  backgroundColor: '#f6f8fa',
                  borderRadius: '4px',
                  fontSize: '12px',
                  color: '#586069'
                }
              }, 'Generating SDL from schema...') :

              error ? React.createElement('div', {
                key: 'error-preview',
                style: {
                  flex: 1,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  backgroundColor: '#ffeaea',
                  borderRadius: '4px',
                  fontSize: '12px',
                  color: '#d73a49',
                  padding: '12px',
                  textAlign: 'center'
                }
              }, `Error generating SDL: ${error}`) :

              React.createElement('pre', {
                key: 'sdl-preview',
                style: {
                  flex: 1,
                  margin: 0,
                  padding: '12px',
                  backgroundColor: '#f6f8fa',
                  borderRadius: '4px',
                  fontSize: '11px',
                  lineHeight: '1.5',
                  color: '#24292e',
                  fontFamily: 'SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace',
                  overflow: 'auto',
                  border: '1px solid #e1e4e8',
                  whiteSpace: 'pre-wrap',
                  wordBreak: 'break-word'
                }
              }, sdlContent)
            ]),

            React.createElement('div', {
              key: 'button-container',
              style: {
                display: 'flex',
                gap: '8px',
                marginTop: '8px',
                alignSelf: 'flex-start'
              }
            }, [
              React.createElement('button', {
                key: 'download-btn',
                onClick: () => {
                  if (sdlContent) {
                    const blob = new Blob([sdlContent], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'schema.graphql';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                  }
                },
                disabled: !sdlContent || loading,
                style: {
                  padding: '8px 16px',
                  backgroundColor: (!sdlContent || loading) ? '#ccc' : '#0366d6',
                  color: 'white',
                  border: 'none',
                  borderRadius: '4px',
                  cursor: (!sdlContent || loading) ? 'not-allowed' : 'pointer',
                  fontSize: '12px',
                  fontWeight: '500'
                },
                onMouseOver: (e) => {
                  if (!(!sdlContent || loading)) {
                    e.target.style.backgroundColor = '#0256cc';
                  }
                },
                onMouseOut: (e) => {
                  if (!(!sdlContent || loading)) {
                    e.target.style.backgroundColor = '#0366d6';
                  }
                }
              }, 'Download schema.graphql'),

              React.createElement('button', {
                key: 'copy-btn',
                onClick: async (e) => {
                  if (sdlContent) {
                    try {
                      await navigator.clipboard.writeText(sdlContent);
                      // Visual feedback - temporarily change button text
                      const btn = e.target;
                      const originalText = btn.textContent;
                      btn.textContent = 'Copied!';
                      btn.style.backgroundColor = '#28a745';
                      setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = '#0366d6';
                      }, 2000);
                    } catch (err) {
                      // Fallback for older browsers
                      const textArea = document.createElement('textarea');
                      textArea.value = sdlContent;
                      textArea.style.position = 'fixed';
                      textArea.style.opacity = '0';
                      document.body.appendChild(textArea);
                      textArea.select();
                      try {
                        document.execCommand('copy');
                        const btn = e.target;
                        const originalText = btn.textContent;
                        btn.textContent = 'Copied!';
                        btn.style.backgroundColor = '#28a745';
                        setTimeout(() => {
                          btn.textContent = originalText;
                          btn.style.backgroundColor = '#0366d6';
                        }, 2000);
                      } catch (fallbackErr) {
                        alert('Failed to copy schema');
                      }
                      document.body.removeChild(textArea);
                    }
                  }
                },
                disabled: !sdlContent || loading,
                style: {
                  padding: '8px 16px',
                  backgroundColor: (!sdlContent || loading) ? '#ccc' : '#0366d6',
                  color: 'white',
                  border: 'none',
                  borderRadius: '4px',
                  cursor: (!sdlContent || loading) ? 'not-allowed' : 'pointer',
                  fontSize: '12px',
                  fontWeight: '500'
                },
                onMouseOver: (e) => {
                  if (!(!sdlContent || loading)) {
                    e.target.style.backgroundColor = '#0256cc';
                  }
                },
                onMouseOut: (e) => {
                  if (!(!sdlContent || loading) && e.target.textContent !== 'Copied!') {
                    e.target.style.backgroundColor = '#0366d6';
                  }
                }
              }, 'Copy schema.graphql')
            ]),

            React.createElement('div', {
              key: 'info',
              style: {
                padding: '12px',
                backgroundColor: '#f6f8fa',
                borderRadius: '4px',
                fontSize: '11px',
                color: '#586069'
              }
            }, 'The SDL is generated from schema introspection and contains the complete schema definition including types, queries, mutations, and subscriptions.')
          ]);
        }
      };



      // Custom GraphQL Type Node Component
      const GraphQLTypeNode = ({ data }) => {
        const { type, getTypeString, getCoreTypeName, isScalarType, onFieldClick, shouldDim, isSelected, isDownstreamOfSelected, schemaData } = data;
        const isQueryType = data.isQueryType;
        const isMutationType = data.isMutationType;
        const isSubscriptionType = data.isSubscriptionType;

        const isRootType = isQueryType || isMutationType || isSubscriptionType;

        // Helper function to get target type description for relationships
        const getTargetTypeDescription = (fieldTypeName) => {
          if (!schemaData || !fieldTypeName) return null;
          const targetType = schemaData.__schema.types.find(t => t.name === fieldTypeName);
          return targetType?.description || null;
        };

        const nodeContent = React.createElement('div', {
          onDoubleClick: (e) => {
            e.preventDefault();
            e.stopPropagation();


            // Trigger the zoom functionality directly
            if (window._handleNodeDoubleClick) {
              window._handleNodeDoubleClick(data.nodeId);
            }
          },
          ref: (el) => {
            if (el && !data.hidden) {
              // Use requestAnimationFrame to ensure measurement happens after layout
              requestAnimationFrame(() => {
                const rect = el.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) { // Only measure if element has size
                  if (!window.measuredNodeDimensions) {
                    window.measuredNodeDimensions = new Map();
                  }
                  // Get React Flow's current zoom to compensate for scaling
                  const currentZoom = data.reactFlowViewport?.zoom || 1;

                  // Use the full rendered dimensions - let ELK work with what's actually displayed
                  // This includes all borders, padding, content - everything that's visually rendered
                  const trueWidth = rect.width / currentZoom;
                  const trueHeight = rect.height / currentZoom;

                  // Only update if dimensions have changed significantly
                  const existing = window.measuredNodeDimensions.get(data.nodeId);
                  if (!existing || Math.abs(existing.width - trueWidth) > 1 || Math.abs(existing.height - trueHeight) > 1) {
                    window.measuredNodeDimensions.set(data.nodeId, {
                      width: trueWidth,
                      height: trueHeight
                    });
                  }
                }
              });
            }
          },
          style: {
            background: isSelected ? 'linear-gradient(135deg, #f0f8ff 0%, #e6f3ff 100%)' :
                       isDownstreamOfSelected ? 'linear-gradient(135deg, #f8f9ff 0%, #f4f6ff 100%)' : 'white',
            border: shouldDim ? '2px solid #e1e4e8' : '2px solid #d1d5da',
            outline: isSelected ? '5px solid #0366d6' :
                    isDownstreamOfSelected ? '3px solid #0366d6' : 'none',
            borderRadius: '8px',
            overflow: 'visible',
            minWidth: isRootType ? '350px' : '280px',
            maxWidth: 'none',
            width: 'fit-content',
            boxShadow: isSelected ? '0 8px 24px rgba(3,102,214,0.4), 0 0 0 1px rgba(3,102,214,0.1)' :
                       isDownstreamOfSelected ? '0 4px 12px rgba(3,102,214,0.2), 0 0 0 1px rgba(3,102,214,0.05)' :
                       shouldDim ? '0 1px 3px rgba(0,0,0,0.05)' : '0 2px 8px rgba(0,0,0,0.1)',
            position: 'relative',
            opacity: data.hidden ? 0 : (shouldDim ? 0.15 : 1), // More faded out for better contrast
            visibility: data.hidden ? 'hidden' : 'visible', // Also use visibility for better performance
            pointerEvents: data.hidden ? 'none' : 'auto', // Disable interaction for hidden nodes
            transform: 'scale(1)',
            zIndex: isSelected ? 10 : isDownstreamOfSelected ? 8 : shouldDim ? 1 : 5,
            transition: 'border 0.2s ease, outline 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, opacity 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)'
          }
        }, [
          // Root type label (subtle header row)
          isRootType && React.createElement('div', {
            key: 'root-type-label',
            style: {
              padding: '6px 16px',
              background: isQueryType ? '#f0f8ff' : isMutationType ? '#fff5f5' : isSubscriptionType ? '#f8f0ff' : '#f6f8fa',
              color: isQueryType ? '#0969da' : isMutationType ? '#d1242f' : '#8250df',
              fontSize: '10px',
              fontWeight: '600',
              textTransform: 'uppercase',
              letterSpacing: '0.5px',
              borderRadius: '6px 6px 0 0',
              borderBottom: '1px solid #e1e4e8'
            }
          }, isQueryType ? 'Query Root Type' : isMutationType ? 'Mutation Root Type' : 'Subscription Root Type'),

          // Header
          React.createElement('div', {
            key: 'header',
            style: {
              padding: '12px 16px',
              background: isQueryType ? '#e6f3ff' : isMutationType ? '#fff5f5' : isSubscriptionType ? '#f0fff4' : '#f6f8fa',
              color: '#24292e',
              borderRadius: isRootType ? '0' : '6px 6px 0 0',
              borderBottom: '1px solid #d1d5da'
            }
          }, [
            React.createElement('div', {
              key: 'header-content',
              style: {
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'flex-start'
              }
            }, [
              React.createElement('div', {
                key: 'title-section',
                style: { flex: 1 }
              }, [
                React.createElement('div', {
                  key: 'title',
                  style: {
                    fontWeight: 'bold',
                    fontSize: isRootType ? '28px' : '24px'
                  },
                  title: type.description || undefined
                }, type.name),
                React.createElement('div', {
                  key: 'kind',
                  style: {
                    fontSize: '16.5px',
                    opacity: 0.9,
                    textTransform: 'uppercase',
                    fontWeight: '500',
                    marginTop: '2px'
                  },
                  title: type.description || undefined
                }, type.kind)
              ])
            ])
          ]),

          // Fields with handles (for objects, interfaces, inputs) OR enum values (for enums)
          (type.fields || type.inputFields || type.enumValues) && React.createElement('div', {
            key: 'fields',
            style: { padding: '0', position: 'relative' }
          }, (type.fields || type.inputFields || type.enumValues).map((field, fieldIndex) => {
            // Handle both fields and enum values
            const isEnumValue = !field.type; // Enum values don't have a type property
            const fieldTypeString = isEnumValue ? '' : getTypeString(field.type);
            const coreTypeName = isEnumValue ? null : getCoreTypeName(field.type);
            const isRelationship = !isEnumValue && coreTypeName && !coreTypeName.startsWith('__') && !isScalarType(coreTypeName);

            // Calculate handle position - accounting for header height (60px) and field position
            const handleTop = 60 + (fieldIndex * 45) + 22; // 22px is half the field height to center the handle
            const totalItems = (type.fields || type.inputFields || type.enumValues).length;

            return React.createElement('div', {
              key: field.name,
              ref: (el) => {
                if (el && !data.hidden) {
                  // Use requestAnimationFrame to ensure measurement happens after layout
                  requestAnimationFrame(() => {
                    const rect = el.getBoundingClientRect();
                    const nodeEl = el.closest('[data-node-id]');
                    if (nodeEl && rect.height > 0) {
                      const nodeRect = nodeEl.getBoundingClientRect();

                      // Calculate exact port position - right edge center of the main field row (top line)
                      // Get React Flow's zoom to compensate for scaling
                      const currentZoom = data.reactFlowViewport?.zoom || 1;

                      // Calculate field position relative to node in screen pixels, then compensate for zoom
                      const fieldTopRelative = rect.top - nodeRect.top;
                      const fieldCenterYRelative = fieldTopRelative + 22.5; // Center of the 45px main field row
                      const portX = (nodeRect.width) / currentZoom; // Use actual node width for consistent positioning
                      const portY = fieldCenterYRelative / currentZoom;

                      // Add small offset adjustment to account for any CSS discrepancies
                      const adjustedPortY = portY - 2; // Adjust down by 2 pixels to account for potential border/margin differences

                      if (!window.measuredFieldPositions) {
                        window.measuredFieldPositions = new Map();
                      }
                      const fieldKey = `${data.nodeId}-${field.name}`;
                      // Only update if position has changed significantly
                      const existing = window.measuredFieldPositions.get(fieldKey);
                      if (!existing || Math.abs(existing.y - adjustedPortY) > 1) {
                        window.measuredFieldPositions.set(fieldKey, {
                          y: adjustedPortY,
                          x: portX,
                          height: rect.height,
                          width: rect.width
                        });
                      }
                    }
                  });
                }
              },
              style: {
                padding: '0',
                borderBottom: fieldIndex < totalItems - 1 ? '1px solid #f1f3f4' : 'none',
                backgroundColor: isRelationship ? '#f8f9ff' : 'white',
                cursor: 'default',
                position: 'relative'
              },
            }, [
              // Main field row
              React.createElement('div', {
                key: 'field-main',
                style: {
                  padding: '8px 16px',
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  minHeight: '45px',
                  gap: '8px',
                  flexWrap: 'nowrap'
                }
              }, [
                React.createElement('span', {
                  key: 'name',
                  style: {
                    color: '#24292e',
                    fontWeight: '500',
                    fontSize: isRootType ? '21px' : '19.5px',
                    wordBreak: 'break-word',
                    overflowWrap: 'break-word',
                    whiteSpace: 'normal',
                    flex: '1 1 auto',
                    marginRight: '8px'
                  },
                  title: field.description || undefined
                }, field.name),
                !isEnumValue && React.createElement('span', {
                  key: 'type',
                  style: {
                    color: isRelationship ? '#0366d6' : '#656d76',
                    fontWeight: isRelationship ? '600' : '400',
                    fontSize: '18px',
                    fontFamily: 'SFMono-Regular, Consolas, monospace',
                    cursor: isRelationship ? 'pointer' : 'default',
                    wordBreak: 'break-word',
                    overflowWrap: 'break-word',
                    whiteSpace: 'normal',
                    flex: '0 0 auto'
                  },
                  title: isRelationship ?
                    (() => {
                      const fieldDesc = field.description || 'No field description';
                      const targetTypeDesc = getTargetTypeDescription(coreTypeName) || 'No type description';
                      return `${fieldDesc}\n\n${coreTypeName}\n${targetTypeDesc}`;
                    })() :
                    (field.description || undefined),
                  onClick: isRelationship ? (e) => {
                    e.stopPropagation();
                    const targetTypeId = `type-${coreTypeName}`;
                    if (onFieldClick) {
                      onFieldClick(targetTypeId);
                    }
                  } : undefined
                }, fieldTypeString)
              ]),

              // Arguments section (only for fields with arguments)
              !isEnumValue && field.args && field.args.length > 0 && React.createElement('div', {
                key: 'field-args',
                style: {
                  padding: '0 16px 8px 48px', // More inset for arguments
                  backgroundColor: 'white' // Always white background for arguments
                }
              }, [
                // Arguments header
                React.createElement('div', {
                  key: 'args-header',
                  style: {
                    fontSize: '10px',
                    fontWeight: 'bold',
                    color: '#999', // Dimmer color
                    marginBottom: '4px',
                    marginLeft: '-16px', // Outdent the header
                    textTransform: 'uppercase',
                    letterSpacing: '0.5px'
                  }
                }, 'Field Arguments'),
                // Arguments list
                ...field.args.map((arg, argIndex) => {
                // Check if argument type is a relationship (not scalar)
                const argCoreTypeName = getCoreTypeName(arg.type);
                const isArgRelationship = argCoreTypeName && !argCoreTypeName.startsWith('__') && !isScalarType(argCoreTypeName);

                return React.createElement('div', {
                  key: `arg-${arg.name}`,
                  ref: (el) => {
                    if (el && !data.hidden) {
                      // Use requestAnimationFrame to ensure measurement happens after layout
                      requestAnimationFrame(() => {
                        const rect = el.getBoundingClientRect();
                        const nodeEl = el.closest('[data-node-id]');
                        if (nodeEl && rect.height > 0) {
                          const nodeRect = nodeEl.getBoundingClientRect();

                          // Calculate exact argument port position - right edge center of the argument row
                          // Get React Flow's zoom to compensate for scaling
                          const currentZoom = data.reactFlowViewport?.zoom || 1;

                          // Calculate argument position relative to node in screen pixels, then compensate for zoom
                          const argTopRelative = rect.top - nodeRect.top;
                          const argCenterYRelative = argTopRelative + (rect.height / 2); // Center of the argument row
                          const portX = (nodeRect.width) / currentZoom; // Use actual node width for consistent positioning
                          const portY = argCenterYRelative / currentZoom;

                          // Add small offset adjustment to account for any CSS discrepancies
                          const adjustedPortY = portY - 2; // Adjust down by 2 pixels to account for potential border/margin differences

                          if (!window.measuredArgumentPositions) {
                            window.measuredArgumentPositions = new Map();
                          }
                          const argKey = `${data.nodeId}-${field.name}-arg-${arg.name}`;
                          // Only update if position has changed significantly
                          const existing = window.measuredArgumentPositions.get(argKey);
                          if (!existing || Math.abs(existing.y - adjustedPortY) > 1) {
                            window.measuredArgumentPositions.set(argKey, {
                              y: adjustedPortY,
                              x: portX,
                              height: rect.height,
                              width: rect.width
                            });
                          }
                        }
                      });
                    }
                  },
                  style: {
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    padding: '4px 0',
                    fontSize: '16px',
                    color: '#999' // Dimmer color for arguments
                  }
                }, [
                  React.createElement('span', {
                    key: 'arg-name',
                    style: {
                      color: '#8c959f', // Lighter color for argument names
                      fontWeight: '400',
                      fontSize: '16px'
                    },
                    title: arg.description || undefined
                  }, arg.name),
                  React.createElement('span', {
                    key: 'arg-type',
                    style: {
                      color: isArgRelationship ? '#0366d6' : '#9ca3af', // Blue for relationships (clickable), grey for scalars
                      fontWeight: '400',
                      fontSize: '16px',
                      fontFamily: 'SFMono-Regular, Consolas, monospace',
                      cursor: isArgRelationship ? 'pointer' : 'default'
                    },
                    title: isArgRelationship ?
                      (() => {
                        const argDesc = arg.description || 'No argument description';
                        const targetTypeDesc = getTargetTypeDescription(argCoreTypeName) || 'No type description';
                        return `${argDesc}\n\n${argCoreTypeName}\n${targetTypeDesc}`;
                      })() :
                      (arg.description || undefined),
                    onClick: isArgRelationship ? (e) => {
                      e.stopPropagation();
                      const targetTypeId = `type-${argCoreTypeName}`;
                      if (onFieldClick) {
                        onFieldClick(targetTypeId);
                      }
                    } : undefined
                  }, getTypeString(arg.type))
                ]);
              })])
            ]);
          })),

        ]);

        return nodeContent;
      };

      // Complete GraphQL Schema Visualizer Plugin using React Flow
      const schemaVisualizerPlugin = {
        title: 'Graph Visualizer',
        key: 'schema-visualizer', // Stable key to prevent remounting
        icon: () => React.createElement('svg', {
          width: '16',
          height: '16',
          viewBox: '0 0 24 24',
          fill: 'currentColor'
        }, [
          // Fork-shaped graph with 6 nodes
          React.createElement('circle', { key: 'node1', cx: '6', cy: '12', r: '2', fill: 'currentColor' }),
          React.createElement('circle', { key: 'node2', cx: '13', cy: '6', r: '2', fill: 'currentColor' }),
          React.createElement('circle', { key: 'node3', cx: '13', cy: '12', r: '2', fill: 'currentColor' }),
          React.createElement('circle', { key: 'node4', cx: '13', cy: '18', r: '2', fill: 'currentColor' }),
          React.createElement('circle', { key: 'node5', cx: '20', cy: '12', r: '2', fill: 'currentColor' }),
          React.createElement('circle', { key: 'node6', cx: '18', cy: '6', r: '2', fill: 'currentColor' }),
          // Fork connections - straight lines branching out
          React.createElement('line', { key: 'line1', x1: '8', y1: '12', x2: '11', y2: '6', stroke: 'currentColor', strokeWidth: '1.2' }),
          React.createElement('line', { key: 'line2', x1: '8', y1: '12', x2: '11', y2: '12', stroke: 'currentColor', strokeWidth: '1.2' }),
          React.createElement('line', { key: 'line3', x1: '8', y1: '12', x2: '11', y2: '18', stroke: 'currentColor', strokeWidth: '1.2' }),
          React.createElement('line', { key: 'line4', x1: '15', y1: '12', x2: '18', y2: '12', stroke: 'currentColor', strokeWidth: '1.2' }),
          React.createElement('line', { key: 'line5', x1: '15', y1: '6', x2: '16', y2: '6', stroke: 'currentColor', strokeWidth: '1.2' })
        ]),
        content: () => {
          const [loading, setLoading] = React.useState(true);
          const [error, setError] = React.useState(null);
          const [schemaData, setSchemaData] = React.useState(null);
          const [showOnlyRootTypes, setShowOnlyRootTypes] = React.useState(false);
          const [layoutedData, setLayoutedData] = React.useState({ nodes: [], edges: [] });
          const [showELKDebug, setShowELKDebug] = React.useState(false); // Hidden by default
        const [showArgumentEdges, setShowArgumentEdges] = React.useState(true); // Always enabled by default
          const [elkDebugData, setElkDebugData] = React.useState(null);
          const [selectedNodeId, setSelectedNodeId] = React.useState(() => {
            // Restore previous selection if returning to tab
            return window._persistedSelectedNodeId || null;
          });

          // Persist selected node ID when it changes
          React.useEffect(() => {
            window._persistedSelectedNodeId = selectedNodeId;
          }, [selectedNodeId]);

          // Removed React Flow instance - using custom viewport
          // React Flow handles viewport state internally, so we don't need these
          // const [viewport, setViewport] = React.useState({ x: -100, y: -100, zoom: 0.8 });
          // const [isPanning, setIsPanning] = React.useState(false);
          // const [panStart, setPanStart] = React.useState(null);
          const [nodes, setNodes] = React.useState([]);
          const [edges, setEdges] = React.useState([]);
          const [edgesFading, setEdgesFading] = React.useState(false);
          const [isTransitioning, setIsTransitioning] = React.useState(false);
          const [graphVisible, setGraphVisible] = React.useState(false); // Start hidden
          const transitionTimeoutRef = React.useRef(null);
          const viewportStateRef = React.useRef(null);
          const keySequenceRef = React.useRef('');

          // Fetch schema data
          React.useEffect(() => {
            // Check if we already have cached schema data
            if (window._cachedSchemaData) {
              console.log('Using cached schema data');
              setSchemaData(window._cachedSchemaData);
              setLoading(false);
              return;
            }

            const fetchSchema = async () => {
              try {
                const introspectionQuery = getIntrospectionQuery();
                const result = await fetcher({
                  query: introspectionQuery,
                  operationName: 'IntrospectionQuery'
                });

                if (result.errors) {
                  throw new Error(result.errors[0].message);
                }

                // Cache the schema data globally
                window._cachedSchemaData = result.data;
                setSchemaData(result.data);
                setLoading(false);
              } catch (err) {
                setError(err.message);
                setLoading(false);
              }
            };

            fetchSchema();
          }, []);

          // Apply layout when schema data changes
          React.useEffect(() => {
            if (!schemaData) return;

            // Check if we already have cached layout data
            if (window._cachedLayoutData) {
              setLayoutedData(window._cachedLayoutData);
              setNodes(window._cachedLayoutData.nodes);
              setEdges(window._cachedLayoutData.edges);

              // Restore cached ELK debug data
              if (window._cachedElkDebugData) {
                setElkDebugData(window._cachedElkDebugData);
              }

              // The highlighting will be updated by the highlighting useEffect that runs after layoutedData changes
              return;
            }

            const applyLayout = async () => {
              const { nodes, edges } = generateCompleteFlowData();

              // First pass: render nodes to get measurements
              setNodes(nodes);
              setEdges(edges);

              // Wait longer for DOM to render and measurements to stabilize
              await new Promise(resolve => setTimeout(resolve, 300));

              // Second pass: apply ELK layout with measured widths
                              const layouted = await getLayoutedElements(nodes, edges, true, true);

              // Cache the layout data globally
              window._cachedLayoutData = layouted;

              setLayoutedData(layouted);
              setNodes(layouted.nodes);
              setEdges(layouted.edges);


              // Handle pending navigation after layout completes
              if (window.pendingNavigation) {
                const targetNodeId = window.pendingNavigation;
                window.pendingNavigation = null;


                // Delay for 1 second to let user see the full view first
                setTimeout(() => {
                  const targetNode = layouted.nodes.find(n => n.id === targetNodeId);
                  if (targetNode) {
                    setSelectedNodeId(targetNodeId);
                  } else {
                  }
                }, 1000); // 1 second delay to let user see the full view
              }
            };

            applyLayout();
          }, [schemaData, showOnlyRootTypes]);

          // Update node and edge highlighting when selection changes (without triggering layout)
          React.useEffect(() => {
            if (!schemaData || !layoutedData.nodes.length) return;

            // Regenerate both nodes and edges with updated highlighting
            const { nodes: newNodes, edges: newEdges } = generateCompleteFlowData();

            // Keep the existing positions from layoutedData but update the data
            const updatedNodes = layoutedData.nodes.map(layoutedNode => {
              const newNodeData = newNodes.find(n => n.id === layoutedNode.id);
              if (newNodeData) {
                return {
                  ...layoutedNode,
                  data: newNodeData.data
                };
              }
              return layoutedNode;
            });

            // Keep the existing edge paths from layoutedData but update the styling
            const updatedEdges = layoutedData.edges.map(layoutedEdge => {
              const newEdgeData = newEdges.find(e => e.id === layoutedEdge.id);
              if (newEdgeData) {
                return {
                  ...layoutedEdge,
                  style: newEdgeData.style,
                  animated: newEdgeData.animated,
                  markerEnd: newEdgeData.markerEnd,
                  labelStyle: newEdgeData.labelStyle
                };
              }
              return layoutedEdge;
            });

            setNodes(updatedNodes);
            setEdges(updatedEdges);
          }, [selectedNodeId, layoutedData.nodes.length]); // Added layoutedData dependency


          // Cleanup transition timeouts on unmount
          React.useEffect(() => {
            return () => {
              if (transitionTimeoutRef.current) {
                clearTimeout(transitionTimeoutRef.current);
              }
            };
          }, []);



          // Keyboard event handler for ELK debug toggle and root types centering
          React.useEffect(() => {
            const handleKeyDown = (event) => {
              // Only handle keys if not typing in an input field
              if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                return;
              }

              // Toggle ELK debug overlay and bounding box with 'd' key
              if (event.key.toLowerCase() === 'd' && !event.ctrlKey && !event.metaKey && !event.altKey) {
                setShowELKDebug(prev => {
                  const newValue = !prev;
                  console.log(`ELK debug overlay ${newValue ? 'enabled' : 'disabled'}`);
                  return newValue;
                });
                event.preventDefault();
              }

              // Center viewport on root types with 'r' key
              if (event.key.toLowerCase() === 'r' && !event.ctrlKey && !event.metaKey && !event.altKey) {
                if (window._centerOnRootTypes) {
                  window._centerOnRootTypes();
                } else {
                }
                event.preventDefault();
              }


            };

            document.addEventListener('keydown', handleKeyDown);
            return () => {
              document.removeEventListener('keydown', handleKeyDown);
            };
          }, []);

          // Safety: ensure edges always fade back in after transitions
          React.useEffect(() => {
            const safetyTimeout = setTimeout(() => {
              if (edgesFading) {
                setEdgesFading(false);
              }
            }, 2000); // Safety timeout after 2 seconds

            return () => clearTimeout(safetyTimeout);
          }, [edgesFading]);

          // Helper function to get clean type string
          const getTypeString = (type) => {
            if (type.kind === 'NON_NULL') {
              return getTypeString(type.ofType) + '!';
            } else if (type.kind === 'LIST') {
              return '[' + getTypeString(type.ofType) + ']';
            } else {
              return type.name || 'Unknown';
            }
          };

          // Helper function to get the core type name from a wrapped type
          const getCoreTypeName = (type) => {
            if (type.kind === 'NON_NULL' || type.kind === 'LIST') {
              let innerType = type.ofType;
              while (innerType && (innerType.kind === 'NON_NULL' || innerType.kind === 'LIST')) {
                innerType = innerType.ofType;
              }
              return innerType?.name;
            }
            return type.name;
          };

          // Check if a type should be displayed as a node
          const shouldDisplayAsNode = (type) => {
            // Don't show introspection types
            if (type.name.startsWith('__')) return false;

            // Don't show built-in scalars
            if (['String', 'Int', 'Float', 'Boolean', 'ID'].includes(type.name)) return false;

            // Show enums, objects, interfaces, unions, and input types
            return ['ENUM', 'OBJECT', 'INTERFACE', 'UNION', 'INPUT_OBJECT'].includes(type.kind);
          };

          // Check if a type is a scalar/built-in type
          const isScalarType = (typeName) => {
            return ['String', 'Int', 'Float', 'Boolean', 'ID'].includes(typeName);
          };

          // ELK layout with debugging
          const getLayoutedElements = async (nodes, edges, waitForMeasurements = false, showArgs = false) => {
            const elk = new ELK();

            // Wait for node measurements if requested
            if (waitForMeasurements) {
              // Give DOM time to render and measure nodes
              await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Filter to only visible nodes and edges for ELK layout calculation
            const visibleNodes = nodes.filter(node => !node.data.hidden);
            const visibleEdges = edges.filter(edge => !edge.data.hidden);

            // Convert React Flow format to ELK format with port information
            const elkNodes = visibleNodes.map((node, nodeIndex) => {
              // Count fields, inputFields, OR enum values
              const itemCount = node.data.type.fields ? node.data.type.fields.length :
                                node.data.type.inputFields ? node.data.type.inputFields.length :
                                node.data.type.enumValues ? node.data.type.enumValues.length : 0;

              // Check if this is a root type (has extra header)
              const isRootType = node.data.isQueryType || node.data.isMutationType || node.data.isSubscriptionType;
              const rootTypeHeaderHeight = isRootType ? 29 : 0; // Extra height for root type header (25 + 4px adjustment)

              // Use exact measured dimensions if available, otherwise fallback to calculations
              let nodeWidth, nodeHeight;
              const isSelected = node.data.isSelected;
              const borderWidth = isSelected ? 3 : 2;

              if (window.measuredNodeDimensions && window.measuredNodeDimensions.has(node.id)) {
                const measured = window.measuredNodeDimensions.get(node.id);
                nodeWidth = measured.width;
                nodeHeight = measured.height;
                console.log(`ELK using measured dimensions for ${node.id}: ${nodeWidth.toFixed(1)} x ${nodeHeight.toFixed(1)}px`);
              } else {
                // Dynamic width calculation based on content
                const minContentWidth = isRootType ? 350 : 280;
                const maxContentWidth = isRootType ? 500 : 400; // Reasonable maximum

                // Calculate required width based on longest field name and type
                let maxRequiredWidth = minContentWidth;
                const items = node.data.type.fields || node.data.type.inputFields || node.data.type.enumValues || [];

                if (items && items.length > 0) {
                  items.forEach(item => {
                    if (item && item.name) {
                      // Estimate text width: field name + type string + padding
                      const fieldName = item.name || '';
                      const fieldType = item.type ? getTypeString(item.type) : '';
                      const estimatedTextWidth = (fieldName.length * (isRootType ? 13 : 12)) + (fieldType.length * 10) + 100; // Conservative estimate with padding
                      maxRequiredWidth = Math.max(maxRequiredWidth, estimatedTextWidth);
                    }
                  });
                }

                // Apply reasonable bounds and add border width
                nodeWidth = Math.min(Math.max(maxRequiredWidth, minContentWidth), maxContentWidth) + (borderWidth * 2);
                console.log(`ELK calculated width for ${node.id}: ${nodeWidth}px (isRoot: ${isRootType}, items: ${items?.length || 0})`);

                // Calculate height including arguments
                let totalHeight = 60 + (itemCount * 45) + rootTypeHeaderHeight + 20;

                // Add extra height for fields with arguments
                items.forEach(item => {
                  if (item.args && item.args.length > 0) {
                    // Add height for each argument (roughly 20px per argument)
                    totalHeight += item.args.length * 20;
                  }
                });

                nodeHeight = Math.max(100, totalHeight);
                console.log(`ELK using calculated dimensions for ${node.id}: ${nodeWidth} x ${nodeHeight}px (isRoot: ${isRootType})`);
              }

              // Create ports for each field that has relationships
              const ports = [];

              // Add target port on the left side of the node
              // Add slight offset based on node index to prevent overlapping target ports
              const targetOffset = (nodeIndex % 5) * 4; // 0, 4, 8, 12, 16 pixel offset
              const targetY = 30 + rootTypeHeaderHeight + targetOffset;
              ports.push({
                id: `${node.id}-target`,
                width: 4,
                height: 4,
                x: -4,
                y: targetY
              });

              // Add source ports for ALL fields, inputFields, OR enum values to maintain correct ordering
              const items = node.data.type.fields || node.data.type.inputFields || node.data.type.enumValues || [];
              items.forEach((item, itemIndex) => {
                const isEnumValue = !item.type; // Enum values don't have a type property

                if (!isEnumValue) {
                  // It's a field - create a port
                  const coreTypeName = getCoreTypeName(item.type);
                  const isRelationship = coreTypeName && !coreTypeName.startsWith('__') && !isScalarType(coreTypeName);
                  const isScalar = isScalarType(coreTypeName);

                  // Use exact measured port position if available, otherwise calculate
                  let portX, portY;
                  const fieldKey = `${node.id}-${item.name}`;
                  if (window.measuredFieldPositions && window.measuredFieldPositions.has(fieldKey)) {
                    const measured = window.measuredFieldPositions.get(fieldKey);
                    portX = measured.x - 2; // Slightly outside the field for better visual connection
                    portY = measured.y;
                    console.log(`Using measured port position for ${fieldKey}: (${portX.toFixed(1)}, ${portY.toFixed(1)})`);
                  } else {
                    // Fallback calculation
                    portX = nodeWidth - 10; // Right edge with some margin
                    portY = 60 + rootTypeHeaderHeight + (itemIndex * 45) + 22 + 22.5;
                    const portOffset = (itemIndex % 3) * 3; // Small offset to prevent overlap
                    portY += portOffset;
                      }
                  ports.push({
                    id: `${node.id}-field-${item.name}`,
                    width: 4,
                    height: 4,
                    x: portX,
                    y: portY,
                    // Preserve metadata for debugging
                    isRelationship: isRelationship,
                    isScalar: isScalar,
                    fieldType: coreTypeName,
                    fieldIndex: itemIndex
                  });
                } else {
                  // It's an enum value - use exact measured port position if available
                  let enumPortX, enumPortY;
                  const enumKey = `${node.id}-${item.name}`;
                  if (window.measuredFieldPositions && window.measuredFieldPositions.has(enumKey)) {
                    const measured = window.measuredFieldPositions.get(enumKey);
                    enumPortX = measured.x - 2; // Slightly outside the field
                    enumPortY = measured.y;
                    console.log(`Using measured port position for enum ${enumKey}: (${enumPortX.toFixed(1)}, ${enumPortY.toFixed(1)})`);
                  } else {
                    // Fallback calculation
                    enumPortX = nodeWidth - 10; // Right edge with margin
                    enumPortY = 60 + (itemIndex * 45) + 22 + 22.5;
                    const enumPortOffset = (itemIndex % 3) * 3; // Small offset to prevent overlap
                    enumPortY += enumPortOffset;
                  }
                  ports.push({
                    id: `${node.id}-enum-${item.name}`,
                    width: 4,
                    height: 4,
                    x: enumPortX,
                    y: enumPortY,
                    // Preserve metadata for debugging
                    isEnumValue: true,
                    fieldIndex: itemIndex
                  });
                }
              });

              // Add argument ports (always enabled)
              {
                items.forEach((item, itemIndex) => {
                  const isEnumValue = !item.type;

                  if (!isEnumValue && item.args && item.args.length > 0) {
                    // Create ports for each argument that is a relationship
                    item.args.forEach((arg, argIndex) => {
                      const argCoreTypeName = getCoreTypeName(arg.type);
                      const isArgRelationship = argCoreTypeName && !argCoreTypeName.startsWith('__') && !isScalarType(argCoreTypeName);

                      if (isArgRelationship) {
                        // Calculate argument port position using measured positions
                        const argKey = `${node.id}-${item.name}-arg-${arg.name}`;
                        let argPortX, argPortY;

                        if (window.measuredArgumentPositions && window.measuredArgumentPositions.has(argKey)) {
                          const measured = window.measuredArgumentPositions.get(argKey);
                          argPortX = measured.x - 2; // Slightly outside the argument for better visual connection
                          argPortY = measured.y;
                          console.log(`Using measured argument port position for ${argKey}: (${argPortX.toFixed(1)}, ${argPortY.toFixed(1)})`);
                        } else {
                          // Fallback calculation - position below the field
                          const fieldKey = `${node.id}-${item.name}`;
                          if (window.measuredFieldPositions && window.measuredFieldPositions.has(fieldKey)) {
                            const fieldMeasured = window.measuredFieldPositions.get(fieldKey);
                            argPortX = fieldMeasured.x - 2;
                            argPortY = fieldMeasured.y + 20 + (argIndex * 12); // Below field port, stacked for multiple args
                          } else {
                            // Final fallback calculation
                            argPortX = nodeWidth - 10;
                            argPortY = 60 + rootTypeHeaderHeight + (itemIndex * 45) + 22 + 22.5 + 20 + (argIndex * 12);
                          }
                        }

                        ports.push({
                          id: `${node.id}-arg-${item.name}-${arg.name}`,
                          width: 3, // Slightly smaller than field ports
                          height: 3,
                          x: argPortX,
                          y: argPortY,
                          // Preserve metadata for debugging
                          isArgumentPort: true,
                          isRelationship: isArgRelationship,
                          fieldName: item.name,
                          argName: arg.name,
                          argType: argCoreTypeName,
                          argIndex: argIndex
                        });

                      }
                    });
                  }
                });
              }

              // Give root types fixed positions on the left with specific ordering
              // isRootType already declared above
              let priority;
              if (node.data.isQueryType) {
                priority = 2000; // Highest priority - top position
              } else if (node.data.isMutationType) {
                priority = 1999; // Second highest - middle position
              } else if (node.data.isSubscriptionType) {
                priority = 1998; // Third highest - bottom position
              } else {
                priority = 1000 - nodeIndex; // Regular nodes get lower priority
              }

              const layoutOptions = {
                'elk.portConstraints': 'FIXED_POS'
              };


              // Set fixed positions and constraints for root types
              if (isRootType) {
                layoutOptions['elk.nodeConstraints'] = 'FIXED_POS';
                layoutOptions['elk.priority'] = priority.toString();

                if (node.data.isQueryType) {
                  layoutOptions['elk.position'] = '(50, 50)';
                } else if (node.data.isMutationType) {
                  layoutOptions['elk.position'] = '(50, 600)'; // Below Query, on the left
                } else if (node.data.isSubscriptionType) {
                  layoutOptions['elk.position'] = '(50, 400)'; // Between Query and Mutation
                }
              } else {
                layoutOptions['elk.priority'] = priority.toString();
                layoutOptions['elk.layered.priority'] = priority.toString();
              }

              return {
                id: node.id,
                width: nodeWidth,
                height: nodeHeight,
                ports: ports,
                layoutOptions: layoutOptions
              };
            });

            // Convert edges with proper port references
            const elkEdges = visibleEdges.map(edge => {
              return {
                id: edge.id,
                sources: [edge.sourceHandle], // sourceHandle is already the full port ID
                targets: [edge.targetHandle] // targetHandle is already the full port ID
              };
            });

            // Identify isolated nodes (no incoming or outgoing edges)
            const connectedNodeIds = new Set();
            visibleEdges.forEach(edge => {
              connectedNodeIds.add(edge.source);
              connectedNodeIds.add(edge.target);
            });

            // Separate nodes into ELK-processed and React Flow-only
            const isolatedNodes = elkNodes.filter(node => !connectedNodeIds.has(node.id));
            const connectedElkNodes = elkNodes.filter(node => connectedNodeIds.has(node.id));

            // Separate root nodes from regular nodes for ELK compound node approach (include ALL root nodes, even isolated ones)
            const rootNodes = elkNodes.filter(node => {
              const originalNode = visibleNodes.find(n => n.id === node.id);
              return originalNode && (originalNode.data.isQueryType || originalNode.data.isMutationType || originalNode.data.isSubscriptionType);
            }).sort((a, b) => {
              // Sort to ensure consistent order: Query, Mutation, Subscription
              const getOrder = (node) => {
                const originalNode = visibleNodes.find(n => n.id === node.id);
                if (originalNode.data.isQueryType) return 0;
                if (originalNode.data.isMutationType) return 1;
                if (originalNode.data.isSubscriptionType) return 2;
                return 3;
              };
              return getOrder(a) - getOrder(b);
            });

            const regularNodes = connectedElkNodes.filter(node => {
              const originalNode = visibleNodes.find(n => n.id === node.id);
              return originalNode && !(originalNode.data.isQueryType || originalNode.data.isMutationType || originalNode.data.isSubscriptionType);
            });

            // Update isolated nodes to exclude root nodes (they should never be isolated)
            const nonRootIsolatedNodes = isolatedNodes.filter(node => {
              const originalNode = visibleNodes.find(n => n.id === node.id);
              return originalNode && !(originalNode.data.isQueryType || originalNode.data.isMutationType || originalNode.data.isSubscriptionType);
            });

            // Calculate positions for each root type within the compound
            const rootTypePositions = new Map();
            let currentY = 0;

            rootNodes.forEach((node, index) => {
              // Use the exact same dimensions that were calculated for the original ELK node
              const originalElkNode = elkNodes.find(n => n.id === node.id);
              const nodeHeight = originalElkNode.height;
              const nodeWidth = originalElkNode.width;

              rootTypePositions.set(node.id, {
                x: 0,
                y: currentY,
                height: nodeHeight,
                width: nodeWidth
              });

              currentY += nodeHeight + 50; // 50px spacing between root types
            });

            // Calculate total compound height with extra buffer for ELK port positioning
            const totalCompoundHeight = currentY - 50 + 50; // Remove last spacing, add 50px buffer for bottom ports

            // Create a compound node that ELK treats as a single unit
            const compoundRootNode = rootNodes.length > 0 ? {
              id: 'compound-root',
              width: rootNodes.length > 0 ? rootTypePositions.get(rootNodes[0].id).width : 320, // Use same width as root nodes
              height: totalCompoundHeight,
              // Collect all ports from root nodes and move them to compound level
              ports: rootNodes.flatMap((node) => {
                const position = rootTypePositions.get(node.id);
                return node.ports.map(port => {
                  const updatedPortId = port.id.replace(node.id, 'compound-root');
                  return {
                    ...port,
                    // Update port ID to use compound-root prefix to match updated edge sources
                    id: updatedPortId,
                    // Adjust port positions to account for actual stacked layout positions
                    y: port.y + position.y
                  };
                });
              }),
              children: rootNodes.map((node) => {
                const position = rootTypePositions.get(node.id);
                return {
                  ...node,
                  ports: [], // Remove ports from children since they're now on compound
                  layoutOptions: {},
                  // Use exact calculated positions and dimensions
                  x: position.x,
                  y: position.y,
                  width: position.width,
                  height: position.height
                };
              }),
              edges: [], // No edges within the compound
              layoutOptions: {
                'elk.algorithm': 'fixed', // Use fixed algorithm to respect child positions
                'elk.padding': '[top=0,left=0,bottom=0,right=0]',
                'elk.portConstraints': 'FIXED_POS'
              }
            } : null;

            // Update edges to reference compound node instead of individual root nodes
            const updatedEdges = elkEdges.map(edge => {
              const rootNodeIds = rootNodes.map(n => n.id);
              const sourceIsRoot = rootNodeIds.some(id => edge.sources[0].startsWith(id));

              if (sourceIsRoot && compoundRootNode) {
                // Replace root node reference with compound node reference
                return {
                  ...edge,
                  sources: edge.sources.map(source => {
                    // Find the longest matching root ID to avoid partial matches
                    const matchingRootId = rootNodeIds
                      .filter(id => source.startsWith(id))
                      .sort((a, b) => b.length - a.length)[0]; // Get the longest match
                    if (matchingRootId) {
                      // Replace the entire root node ID with compound-root
                      const updatedSource = source.replace(matchingRootId, 'compound-root');
                      return updatedSource;
                    }
                    return source;
                  })
                };
              }
              return edge;
            });

            // Debug final compound node structure
            if (compoundRootNode) {
            }

            const elkGraph = {
              id: 'root',
              children: compoundRootNode ? [compoundRootNode, ...regularNodes] : elkNodes,
              edges: compoundRootNode ? updatedEdges : elkEdges,
              layoutOptions: {
                'elk.algorithm': 'layered',
                'elk.direction': 'RIGHT',
                'elk.spacing.nodeNode': '40',
                'elk.layered.spacing.nodeNodeBetweenLayers': '220',
                'elk.spacing.edgeNode': '120',
                'elk.spacing.edgeEdge': '50',
                'elk.edgeRouting': 'POLYLINE',
                'elk.layered.mergeEdges': 'false',
                'elk.layered.unnecessaryBendpoints': 'false',
                'elk.layered.edgeRouting.polyline.sloppyRouting': 'false',
                'elk.layered.edgeRouting.polyline.slopedEdgeZoneWidth': '4',
                'elk.spacing.portPort': '25',
                'elk.portAlignment.default': 'DISTRIBUTED',
                'elk.layered.edgeRouting.multiEdgeSpacing': '70',
                'elk.layered.edgeRouting.sloppySplineRouting': 'false',
                'elk.separateConnectedComponents': 'false',
                'elk.padding': '[top=30,left=30,bottom=30,right=30]',
                'elk.portConstraints': 'FIXED_POS',
                'elk.nodeConstraints': 'LAYER_CONSTRAINT'
              }
            };

            try {
              console.log('ELK Input:', elkGraph);


              const layoutedGraph = await elk.layout(elkGraph);
              console.log('ELK Output:', layoutedGraph);

              // Store the layout data for fit view functionality
              window._lastELKLayoutData = null; // Will be set after processing

              // Flatten compound node structure and adjust positions
              let flattenedNodes = [];
              layoutedGraph.children.forEach(child => {
                if (child.id === 'compound-root' && child.children) {
                  // Extract individual nodes from compound and adjust their positions relative to compound position
                  child.children.forEach(rootNode => {
                    // Restore ports to the individual root nodes for proper edge routing
                    const position = rootTypePositions.get(rootNode.id);
                    const originalNode = rootNodes.find(n => n.id === rootNode.id);

                    rootNode.x += child.x;
                    rootNode.y += child.y;
                    rootNode.ports = originalNode.ports; // Restore original ports
                    flattenedNodes.push(rootNode);
                  });
                } else {
                  flattenedNodes.push(child);
                }
              });


              // Store ELK debug data - preserve our custom port properties
              flattenedNodes.forEach(elkNode => {
                if (elkNode.ports) {
                  elkNode.ports.forEach(elkPort => {
                    // Find the original port - for compound node, look in the compound's ports
                    let originalPort;
                    if (elkNode.id === 'compound-root') {
                      // Find original port in the compound node's port collection
                      const compound = layoutedGraph.children.find(n => n.id === 'compound-root');
                      originalPort = compoundRootNode?.ports.find(p => p.id === elkPort.id);
                    } else {
                      // Regular node - find in original elkNodes
                      let originalNode = elkNodes.find(n => n.id === elkNode.id);
                      originalPort = originalNode?.ports.find(p => p.id === elkPort.id);
                    }

                    if (originalPort) {
                      elkPort.isRelationship = originalPort.isRelationship;
                      elkPort.isScalar = originalPort.isScalar;
                      elkPort.fieldType = originalPort.fieldType;
                    }
                  });
                }
              });

              // Update layoutedGraph with flattened nodes for React Flow
              layoutedGraph.children = flattenedNodes;

              setElkDebugData(layoutedGraph);

              // Cache ELK debug data globally
              window._cachedElkDebugData = layoutedGraph;

              // Apply positions back to React Flow nodes (only for visible nodes)
              const originalPositions = {};

              // Apply ELK positions to React Flow nodes - create new array to trigger React re-render
              const updatedNodes = nodes.map(node => {
                originalPositions[node.id] = { ...node.position };

                // Only update positions for visible nodes
                if (!node.data.hidden) {
                  const elkNode = flattenedNodes.find(n => n.id === node.id);
                  if (elkNode) {
                    // Node was processed by ELK - use positions directly
                    // Positions should be in the same coordinate system
                    const newPosition = {
                      x: elkNode.x,
                      y: elkNode.y
                    };
                    return {
                      ...node,
                      position: newPosition
                    };
                  } else {
                    // Isolated node - use simple React Flow positioning (only for non-root nodes)
                    const isIsolated = nonRootIsolatedNodes.find(n => n.id === node.id);
                    if (isIsolated) {
                      // Find the maximum Y position of all ELK-processed nodes
                      let maxY = 0;
                      flattenedNodes.forEach(elkNode => {
                        maxY = Math.max(maxY, elkNode.y + 300); // Add node height buffer
                      });

                      // Position isolated nodes in a grid below all ELK nodes
                      const isolatedIndex = nonRootIsolatedNodes.findIndex(n => n.id === node.id);
                      const newPosition = {
                        x: 100 + (isolatedIndex % 4) * 350, // 4 columns starting from left
                        y: maxY + 100 + Math.floor(isolatedIndex / 4) * 250 // Below ELK nodes with spacing
                      };
                      return {
                        ...node,
                        position: newPosition
                      };
                    }
                  }
                }
                // Hidden nodes keep their original positions (for DOM stability)
                return node;
              });

              // Match React Flow edges with ELK output edges - don't update IDs, keep them matching
              const updatedReactFlowEdges = edges.map(edge => {
                const rootNodeIds = rootNodes.map(n => n.id);
                const sourceIsRoot = rootNodeIds.some(id => edge.source === id);

                if (sourceIsRoot && compoundRootNode) {
                  // Keep the original edge ID to match ELK output, but ensure elkEdgeData is set
                  return {
                    ...edge,
                    data: {
                      ...edge.data,
                      elkEdgeData: true // Ensure this edge uses ELK data
                    }
                    // Keep original ID and source for matching with ELK output
                  };
                }
                return edge;
              });

              // Generate SVG path data for edges using ELK routing
              const generateSVGPath = (elkEdge, elkNodes) => {
                if (!elkEdge.sections || elkEdge.sections.length === 0) {
                  // Simple straight line if no routing data
                  const sourceNode = elkNodes.find(n => n.id === elkEdge.sources[0]);
                  const targetNode = elkNodes.find(n => n.id === elkEdge.targets[0]);
                  if (!sourceNode || !targetNode) return '';

                  const startX = sourceNode.x + sourceNode.width;
                  const startY = sourceNode.y + sourceNode.height / 2;
                  const endX = targetNode.x;
                  const endY = targetNode.y + targetNode.height / 2;

                  return `M ${startX} ${startY} L ${endX} ${endY}`;
                }

                // Use ELK routing data to create smooth curved path
                const section = elkEdge.sections[0];
                let startPoint = section.startPoint;
                const endPoint = section.endPoint;
                const originalBendPoints = section.bendPoints || [];

                // Try to use measured port position for more accurate start point
                const sourceNodeData = edges.find(e => e.id === elkEdge.id);
                if (sourceNodeData && window.measuredFieldPositions) {
                  const sourceHandle = sourceNodeData.sourceHandle;
                  if (sourceHandle) {
                    // Try to get measured position - handle both field and argument formats
                    let measuredPos = window.measuredFieldPositions.get(sourceHandle);

                    // If not found and it's an argument, try the argument positions map
                    if (!measuredPos && sourceHandle.includes('-arg-') && window.measuredArgumentPositions) {
                      measuredPos = window.measuredArgumentPositions.get(sourceHandle);
                    }

                    if (measuredPos) {
                      const sourceNode = elkNodes.find(n => n.id === sourceNodeData.source);
                      if (sourceNode) {
                        // Use measured position for precise alignment
                        startPoint = {
                          x: sourceNode.x + measuredPos.x,
                          y: sourceNode.y + measuredPos.y
                        };
                        console.log(`Using measured start point for ${sourceHandle}: (${startPoint.x.toFixed(1)}, ${startPoint.y.toFixed(1)})`);
                      }
                    } else {
                      // If no measured position yet, use a more conservative fallback that works better with timing issues
                      const sourceNode = elkNodes.find(n => n.id === sourceNodeData.source);
                      if (sourceNode) {
                        // Use node right edge as fallback - more reliable than ELK's calculated position
                        startPoint = {
                          x: sourceNode.x + sourceNode.width - 2, // 2px margin from edge
                          y: startPoint.y // Keep ELK's Y position
                        };
                      }
                    }
                  }
                }

                // Post-process: Create smooth corner rounding with proper arc generation
                const createSmoothCorners = (points) => {
                  if (points.length < 3) return points;

                  const newPoints = [points[0]]; // Always keep first point

                  for (let i = 1; i < points.length - 1; i++) {
                    const prev = points[i - 1];
                    const current = points[i];
                    const next = points[i + 1];

                    // Calculate vectors and angle
                    const v1 = { x: current.x - prev.x, y: current.y - prev.y };
                    const v2 = { x: next.x - current.x, y: next.y - current.y };

                    const len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                    const len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);

                    if (len1 > 0 && len2 > 0) {
                      const dot = (v1.x * v2.x + v1.y * v2.y) / (len1 * len2);
                      const angle = Math.acos(Math.max(-1, Math.min(1, dot)));

                      // Apply rounding to any corner > 30 degrees
                      if (angle > Math.PI / 6) {
                        const unit1 = { x: v1.x / len1, y: v1.y / len1 };
                        const unit2 = { x: v2.x / len2, y: v2.y / len2 };

                        // Dynamic radius based on angle and available space
                        const maxRadius = Math.min(len1, len2) * 0.4;
                        const angleStrength = Math.pow(angle / Math.PI, 0.7); // Non-linear scaling
                        const radius = maxRadius * angleStrength;

                        // Find the corner rounding points
                        const cornerStart = {
                          x: current.x - unit1.x * radius,
                          y: current.y - unit1.y * radius
                        };

                        const cornerEnd = {
                          x: current.x + unit2.x * radius,
                          y: current.y + unit2.y * radius
                        };

                        // Generate multiple points along a smooth arc
                        const numArcPoints = Math.max(3, Math.floor(angle * 4)); // More points for sharper turns
                        const arcPoints = [];

                        for (let j = 0; j <= numArcPoints; j++) {
                          const t = j / numArcPoints;

                          // Create a smooth arc using quadratic bezier with the original corner as control point
                          const arcPoint = {
                            x: (1 - t) * (1 - t) * cornerStart.x + 2 * (1 - t) * t * current.x + t * t * cornerEnd.x,
                            y: (1 - t) * (1 - t) * cornerStart.y + 2 * (1 - t) * t * current.y + t * t * cornerEnd.y
                          };

                          arcPoints.push(arcPoint);
                        }

                        // Add all arc points (this creates a smooth rounded corner)
                        newPoints.push(...arcPoints);
                      } else {
                        newPoints.push(current);
                      }
                    } else {
                      newPoints.push(current);
                    }
                  }

                  newPoints.push(points[points.length - 1]); // Always keep last point
                  return newPoints;
                };

                // Apply smooth corner rounding to the full point sequence
                const allOriginalPoints = [startPoint, ...originalBendPoints, endPoint];
                const processedPoints = createSmoothCorners(allOriginalPoints);

                // Extract the processed bend points (excluding start and end)
                const bendPoints = processedPoints.slice(1, -1);

                if (bendPoints.length === 0) {
                  // Simple direct connection with smooth S-curve
                  const dx = endPoint.x - startPoint.x;
                  const dy = endPoint.y - startPoint.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);

                  // Adaptive control point distance based on connection length
                  const controlDistance = Math.min(distance * 0.4, 120);

                  const cp1x = startPoint.x + controlDistance;
                  const cp1y = startPoint.y;
                  const cp2x = endPoint.x - controlDistance;
                  const cp2y = endPoint.y;

                  return `M ${startPoint.x} ${startPoint.y} C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${endPoint.x} ${endPoint.y}`;
                }

                // Create smooth spline through all points using cubic bezier segments
                const allPoints = [startPoint, ...bendPoints, endPoint];
                let path = `M ${allPoints[0].x} ${allPoints[0].y}`;

                for (let i = 0; i < allPoints.length - 1; i++) {
                  const current = allPoints[i];
                  const next = allPoints[i + 1];
                  const prev = i > 0 ? allPoints[i - 1] : null;
                  const nextNext = i < allPoints.length - 2 ? allPoints[i + 2] : null;

                  // Calculate smooth control points that create continuous tangents
                  let cp1x, cp1y, cp2x, cp2y;

                  if (i === 0) {
                    // First segment - start horizontally
                    const distance = Math.sqrt((next.x - current.x) ** 2 + (next.y - current.y) ** 2);
                    const tension = Math.min(distance * 0.3, 80);

                    cp1x = current.x + tension;
                    cp1y = current.y;

                    // Second control point considers the next point if available
                    if (nextNext) {
                      const nextDir = { x: nextNext.x - next.x, y: nextNext.y - next.y };
                      const nextLength = Math.sqrt(nextDir.x ** 2 + nextDir.y ** 2);
                      if (nextLength > 0) {
                        cp2x = next.x - (nextDir.x / nextLength) * tension * 0.5;
                        cp2y = next.y - (nextDir.y / nextLength) * tension * 0.5;
                      } else {
                        cp2x = next.x - tension * 0.5;
                        cp2y = next.y;
                      }
                    } else {
                      // Last point - approach horizontally
                      cp2x = next.x - tension * 0.7;
                      cp2y = next.y;
                    }
                  } else if (i === allPoints.length - 2) {
                    // Last segment - end horizontally
                    const distance = Math.sqrt((next.x - current.x) ** 2 + (next.y - current.y) ** 2);
                    const tension = Math.min(distance * 0.3, 80);

                    // First control point continues from previous direction
                    if (prev) {
                      const prevDir = { x: current.x - prev.x, y: current.y - prev.y };
                      const prevLength = Math.sqrt(prevDir.x ** 2 + prevDir.y ** 2);
                      if (prevLength > 0) {
                        cp1x = current.x + (prevDir.x / prevLength) * tension * 0.5;
                        cp1y = current.y + (prevDir.y / prevLength) * tension * 0.5;
                      } else {
                        cp1x = current.x + tension * 0.5;
                        cp1y = current.y;
                      }
                    } else {
                      cp1x = current.x + tension * 0.5;
                      cp1y = current.y;
                    }

                    cp2x = next.x - tension;
                    cp2y = next.y;
                  } else {
                    // Middle segments - create smooth continuity
                    const prevDir = prev ? { x: current.x - prev.x, y: current.y - prev.y } : { x: 1, y: 0 };
                    const nextDir = { x: next.x - current.x, y: next.y - current.y };
                    const nextNextDir = nextNext ? { x: nextNext.x - next.x, y: nextNext.y - next.y } : { x: 1, y: 0 };

                    // Normalize directions
                    const prevLength = Math.sqrt(prevDir.x ** 2 + prevDir.y ** 2) || 1;
                    const nextLength = Math.sqrt(nextDir.x ** 2 + nextDir.y ** 2) || 1;
                    const nextNextLength = Math.sqrt(nextNextDir.x ** 2 + nextNextDir.y ** 2) || 1;

                    prevDir.x /= prevLength;
                    prevDir.y /= prevLength;
                    nextDir.x /= nextLength;
                    nextDir.y /= nextLength;
                    nextNextDir.x /= nextNextLength;
                    nextNextDir.y /= nextNextLength;

                    // Calculate tangent at current point (average of incoming and outgoing directions)
                    const tangent = {
                      x: (prevDir.x + nextDir.x) * 0.5,
                      y: (prevDir.y + nextDir.y) * 0.5
                    };
                    const tangentLength = Math.sqrt(tangent.x ** 2 + tangent.y ** 2) || 1;
                    tangent.x /= tangentLength;
                    tangent.y /= tangentLength;

                    // Calculate tangent at next point
                    const nextTangent = {
                      x: (nextDir.x + nextNextDir.x) * 0.5,
                      y: (nextDir.y + nextNextDir.y) * 0.5
                    };
                    const nextTangentLength = Math.sqrt(nextTangent.x ** 2 + nextTangent.y ** 2) || 1;
                    nextTangent.x /= nextTangentLength;
                    nextTangent.y /= nextTangentLength;

                    // Set control points along tangents
                    const tension = Math.min(nextLength * 0.3, 60);

                    cp1x = current.x + tangent.x * tension;
                    cp1y = current.y + tangent.y * tension;
                    cp2x = next.x - nextTangent.x * tension;
                    cp2y = next.y - nextTangent.y * tension;
                  }

                  path += ` C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${next.x} ${next.y}`;
                }

                return path;
              };

              // Add path data to edges
              const finalEdges = (compoundRootNode ? updatedReactFlowEdges : edges).map(edge => {
                const elkEdge = layoutedGraph.edges?.find(e => e.id === edge.id);
                if (elkEdge) {
                  return {
                    ...edge,
                    data: {
                      ...edge.data,
                      pathData: generateSVGPath(elkEdge, flattenedNodes)
                    }
                  };
                }
                return edge;
              });

              // Check if we have any measured positions - if not, schedule a retry after a delay
              const hasMeasuredPositions = window.measuredFieldPositions && window.measuredFieldPositions.size > 0;
              if (!hasMeasuredPositions && !window.layoutRetryScheduled) {
                window.layoutRetryScheduled = true;
                console.log('No measured positions found, scheduling layout retry in 500ms');
                setTimeout(() => {
                  window.layoutRetryScheduled = false;
                  if (window.measuredFieldPositions && window.measuredFieldPositions.size > 0) {
                    console.log('Retrying layout with measured positions');
                    // Trigger a re-layout if we now have measurements
                    setNodes(currentNodes => [...currentNodes]);
                  }
                }, 500);
              }

              // Store the final layout data for fit view functionality
              window._lastELKLayoutData = {
                nodes: updatedNodes,
                edges: finalEdges,
                elkGraph: layoutedGraph
              };

              return { nodes: updatedNodes, edges: finalEdges, elkGraph: layoutedGraph };
            } catch (error) {
              console.error('ELK layout failed:', error);
              // Fallback to simple grid layout (only for visible nodes)
              const visibleNodesList = nodes.filter(node => !node.data.hidden);
              visibleNodesList.forEach((node, index) => {
                const cols = Math.ceil(Math.sqrt(visibleNodesList.length));
                const row = Math.floor(index / cols);
                const col = index % cols;
                node.position = {
                  x: col * 400 + 50,
                  y: row * 300 + 50
                };
              });
              return { nodes, edges };
            }
          };

          // Get downstream node IDs for a given node (only nodes this node points to)
          const getDownstreamNodeIds = (nodeId) => {
            if (!layoutedData.edges) return new Set();
            const downstreamIds = new Set();

            layoutedData.edges.forEach(edge => {
              if (edge.source === nodeId) {
                downstreamIds.add(edge.target); // Only add targets, not sources
              }
            });

            return downstreamIds;
          };

          // Track click timeout to distinguish single vs double click
          const clickTimeoutRef = React.useRef(null);

          // Handle node click
          const onNodeClick = React.useCallback((event, node) => {

            // Clear any existing timeout
            if (clickTimeoutRef.current) {
              clearTimeout(clickTimeoutRef.current);
              clickTimeoutRef.current = null;
            }

            // Set a timeout to handle single click - delayed to allow double-click to cancel
            clickTimeoutRef.current = setTimeout(() => {

              // Use functional update to avoid dependency on selectedNodeId
              setSelectedNodeId(currentSelectedId => {
                if (currentSelectedId === node.id) {
                  return null; // Deselect if clicking the same node
                } else {
                  // Clear old focus bounds when switching to a different node
                  delete window._lastFocusBounds;
                  return node.id;
                }
              });

              clickTimeoutRef.current = null;
            }, 250); // 250ms delay to wait for potential double-click
          }, []); // No dependencies needed now

          // Handle clicking on empty space to deselect
          const onPaneClick = React.useCallback(() => {
            setSelectedNodeId(null);
          }, []);

          // Clear focus bounds when node is deselected
          React.useEffect(() => {
            if (!selectedNodeId) {
              // Clear focus bounds when no node is selected
              delete window._lastFocusBounds;
            }
          }, [selectedNodeId]);

          // Handle node double-click to center and zoom to fit downstream nodes
          const onNodeDoubleClick = React.useCallback((event, node) => {
            // Clear the click timeout to prevent any interference
            if (clickTimeoutRef.current) {
              clearTimeout(clickTimeoutRef.current);
              clickTimeoutRef.current = null;
            }

            // Custom viewport - no React Flow dependency needed

            // Get all downstream nodes
            const downstreamIds = getDownstreamNodeIds(node.id);
            const nodesToFit = [node, ...layoutedData.nodes.filter(n => downstreamIds.has(n.id))];



            // Immediately select the node to show highlighted descendants
            setSelectedNodeId(node.id);

            // Calculate bounds immediately (no need to wait)
            setTimeout(() => {
              // Get all downstream nodes (highlighted descendants)
              const downstreamIds = getDownstreamNodeIds(node.id);
              const nodesToFit = [node, ...layoutedData.nodes.filter(n => downstreamIds.has(n.id))];

              if (nodesToFit.length === 0) return;

              // Calculate bounds of all nodes to fit
              let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

              nodesToFit.forEach(n => {
                // Get actual measured dimensions if available
                let nodeWidth = 350;
                let nodeHeight = 200;

                if (window.measuredNodeDimensions && window.measuredNodeDimensions.has(n.id)) {
                  const measured = window.measuredNodeDimensions.get(n.id);
                  nodeWidth = measured.width;
                  nodeHeight = measured.height;
                }

                minX = Math.min(minX, n.position.x);
                minY = Math.min(minY, n.position.y);
                maxX = Math.max(maxX, n.position.x + nodeWidth);
                maxY = Math.max(maxY, n.position.y + nodeHeight);
              });

              // Add padding around the focused area (nodes only, no edges)
              const padding = 100;
              const bounds = {
                x: minX - padding,
                y: minY - padding,
                width: maxX - minX + (padding * 2),
                height: maxY - minY + (padding * 2)
              };

              // Apply viewport change using the same mechanism as focus bounds
              window._focusBounds = bounds;
              // Store debug info for ELK debug overlay
              window._lastFocusBounds = bounds;

            }, 100);
          }, [layoutedData.nodes, getDownstreamNodeIds]);

          // Set up global double-click handler for nodes to use
          React.useEffect(() => {
            window._handleNodeDoubleClick = (nodeId) => {

              // Find the node
              const node = layoutedData.nodes.find(n => n.id === nodeId);
              if (!node) {
                return;
              }

              // Call the existing double-click logic
              onNodeDoubleClick(null, node);
            };

            // Cleanup
            return () => {
              delete window._handleNodeDoubleClick;
            };
          }, [layoutedData.nodes, onNodeDoubleClick]);

          // Handle field click to center on target node (like double-click)
          const onFieldClick = React.useCallback((targetNodeId) => {
            if (targetNodeId) {
              // Find the target node and trigger double-click behavior to move viewport
              const targetNode = layoutedData.nodes.find(n => n.id === targetNodeId);
              if (targetNode) {
                // Trigger the same behavior as double-clicking the node
                onNodeDoubleClick(null, targetNode);
              }
            }
          }, [layoutedData.nodes, onNodeDoubleClick]);

          // Helper functions for type ancestry analysis
          const getTypeDescendants = (typeName, visited = new Set()) => {
            if (!schemaData || visited.has(typeName)) return new Set();
            visited.add(typeName);

            const descendants = new Set();
            const type = schemaData.__schema.types.find(t => t.name === typeName);

            if (type && (type.fields || type.inputFields)) {
              const fields = type.fields || type.inputFields;
              fields.forEach(field => {
                const coreTypeName = getCoreTypeName(field.type);
                if (coreTypeName && !coreTypeName.startsWith('__') && !isScalarType(coreTypeName)) {
                  descendants.add(coreTypeName);
                  // Recursively get descendants
                  const nestedDescendants = getTypeDescendants(coreTypeName, visited);
                  nestedDescendants.forEach(desc => descendants.add(desc));
                }
              });
            }

            return descendants;
          };

          const classifyTypes = () => {
            if (!schemaData) return { queryTypes: new Set(), mutableTypes: new Set(), sharedTypes: new Set() };

            const queryRootName = schemaData.__schema.queryType?.name;
            const mutationRootName = schemaData.__schema.mutationType?.name;
            const subscriptionRootName = schemaData.__schema.subscriptionType?.name;

            // Get all descendants of query root
            const queryDescendants = queryRootName ? getTypeDescendants(queryRootName) : new Set();
            if (queryRootName) queryDescendants.add(queryRootName);

            // Get all descendants of mutation root
            const mutationDescendants = mutationRootName ? getTypeDescendants(mutationRootName) : new Set();
            if (mutationRootName) mutationDescendants.add(mutationRootName);

            // Add subscription root to query graph for now
            if (subscriptionRootName) {
              queryDescendants.add(subscriptionRootName);
              const subscriptionDescendants = getTypeDescendants(subscriptionRootName);
              subscriptionDescendants.forEach(desc => queryDescendants.add(desc));
            }

            // Find shared types (appear in both graphs)
            const sharedTypes = new Set();
            mutationDescendants.forEach(type => {
              if (queryDescendants.has(type)) {
                sharedTypes.add(type);
              }
            });

            // Mutable types are those that belong to mutation but not query (excluding shared)
            const mutableTypes = new Set();
            mutationDescendants.forEach(type => {
              if (!queryDescendants.has(type)) {
                mutableTypes.add(type);
              }
            });

            return { queryTypes: queryDescendants, mutableTypes, sharedTypes };
          };

          // Generate React Flow nodes and edges using table-like approach
          const generateCompleteFlowData = () => {
            if (!schemaData) return { nodes: [], edges: [] };

            const nodes = [];
            const edges = [];

            // Get all types that should be displayed as nodes
            const allTypes = schemaData.__schema.types.filter(shouldDisplayAsNode);

            // Classify types into partitions
            const { queryTypes, mutableTypes, sharedTypes } = classifyTypes();

            // Determine which types should be visible (but create nodes for ALL types)
            let visibleTypeNames = new Set();

            if (showOnlyRootTypes) {
              // Root types only mode
              allTypes.forEach(type => {
                const isQueryType = type.name === schemaData.__schema.queryType?.name;
                const isMutationType = type.name === schemaData.__schema.mutationType?.name;
                const isSubscriptionType = type.name === schemaData.__schema.subscriptionType?.name;
                if (isQueryType || isMutationType || isSubscriptionType) {
                  visibleTypeNames.add(type.name);
                }
              });
            } else {
              // Show all types
              allTypes.forEach(type => {
                visibleTypeNames.add(type.name);
              });
            }

            // Always create nodes for ALL types, but mark visibility
            const typesToShow = allTypes;

            // Create table-like nodes for each type
            typesToShow.forEach((type, typeIndex) => {
              const isQueryType = type.name === schemaData.__schema.queryType?.name;
              const isMutationType = type.name === schemaData.__schema.mutationType?.name;
              const isSubscriptionType = type.name === schemaData.__schema.subscriptionType?.name;

              // Initial position - use a grid layout for better initial visibility
              const nodeIndex = nodes.length;
              const nodesPerRow = 4;
              const columnSpacing = 400;
              const rowSpacing = 300;

              // Position root types on the left, others in a grid
              let x, y;
              if (isQueryType || isMutationType || isSubscriptionType) {
                x = 50; // Always on the left for root types
                y = isQueryType ? 50 : isMutationType ? 400 : 750; // Vertical positions for root types
              } else {
                const col = nodeIndex % nodesPerRow;
                const row = Math.floor(nodeIndex / nodesPerRow);
                x = 500 + (col * columnSpacing); // Start after root types column
                y = 50 + (row * rowSpacing);
              }

              // Calculate field information for handles
              const fields = type.fields || type.inputFields || [];
              const relationshipFields = fields.filter(field => {
                const coreTypeName = getCoreTypeName(field.type);
                return coreTypeName && !coreTypeName.startsWith('__') && !isScalarType(coreTypeName);
              });

              const typeNodeId = `type-${type.name}`;
              const downstreamNodeIds = getDownstreamNodeIds(typeNodeId);
              const isSelected = selectedNodeId === typeNodeId;
              const isSelectedDownstream = selectedNodeId && downstreamNodeIds.has(selectedNodeId);
              const isDownstreamOfSelected = selectedNodeId && getDownstreamNodeIds(selectedNodeId).has(typeNodeId);
              const shouldDim = selectedNodeId && !isSelected && !isDownstreamOfSelected;
              const isVisible = visibleTypeNames.has(type.name);

              // Determine partition membership
              const isInQueryPartition = queryTypes.has(type.name);
              const isInMutablePartition = mutableTypes.has(type.name);
              const isSharedType = sharedTypes.has(type.name);
              const partition = isInMutablePartition ? 'mutable' : 'query'; // Default to query partition

              nodes.push({
                id: typeNodeId,
                type: 'graphqlType',
                position: { x, y },
                className: 'smooth-node-transition',
                style: !isVisible ? { opacity: 0, visibility: 'hidden', pointerEvents: 'none' } : {},
                data: {
                  nodeId: typeNodeId,
                  type,
                  isQueryType,
                  isMutationType,
                  isSubscriptionType,
                  partition,
                  isInQueryPartition,
                  isInMutablePartition,
                  isSharedType,
                  getTypeString,
                  getCoreTypeName,
                  isScalarType,
                  onFieldClick,
                  shouldDim,
                  isSelected,
                  isDownstreamOfSelected,
                  isTransitioning,
                  hidden: !isVisible, // Add hidden property for DOM stability
                  schemaData // Add schema data for relationship tooltips
                }
              });

              // Create edges for field relationships
              const typeFields = type.fields || type.inputFields;
              if (typeFields) {
                typeFields.forEach((field, fieldIndex) => {
                  const coreTypeName = getCoreTypeName(field.type);

                  // Only create edges for non-scalar types that exist in our node set
                  if (coreTypeName &&
                      !coreTypeName.startsWith('__') &&
                      !isScalarType(coreTypeName) &&
                      typesToShow.some(t => t.name === coreTypeName)) {

                    const targetTypeId = `type-${coreTypeName}`;
                    const edgeId = `${typeNodeId}-${field.name}-${targetTypeId}`;

                    // Determine edge highlighting state - only highlight downstream edges
                    const isSourceSelected = selectedNodeId === typeNodeId;
                    const isTargetSelected = selectedNodeId === targetTypeId;
                    const isDownstreamEdge = isSourceSelected; // Only edges FROM the selected node
                    const isUpstreamEdge = isTargetSelected; // Edges TO the selected node (should be dimmed)
                    const shouldDimEdge = selectedNodeId && !isDownstreamEdge;

                    // Check if edge should be visible based on source and target visibility
                    const isSourceVisible = visibleTypeNames.has(type.name);
                    const isTargetVisible = visibleTypeNames.has(coreTypeName);
                    const isEdgeVisible = isSourceVisible && isTargetVisible;

                    edges.push({
                      id: edgeId,
                      source: typeNodeId,
                      target: targetTypeId,
                      sourceHandle: `${typeNodeId}-field-${field.name}`,
                      targetHandle: `${targetTypeId}-target`,
                      type: 'elk', // Use ELK-calculated edge paths
                      animated: isDownstreamEdge,
                      style: {
                        stroke: isDownstreamEdge ? '#0366d6' : shouldDimEdge ? '#d1d5da' : '#d0d0d0',
                        strokeWidth: isDownstreamEdge ? 3 : shouldDimEdge ? 1 : 2,
                        strokeDasharray: '0',
                        opacity: shouldDimEdge ? 0.3 : 1
                      },
                      markerEnd: {
                        type: 'arrowclosed',
                        color: isDownstreamEdge ? '#0366d6' : shouldDimEdge ? '#d1d5da' : '#d0d0d0',
                        width: isDownstreamEdge ? 16 : 12,
                        height: isDownstreamEdge ? 16 : 12
                      },
                      label: field.name,
                      labelStyle: {
                        fontSize: '10px',
                        color: isDownstreamEdge ? '#0366d6' : shouldDimEdge ? '#656d76' : '#24292e',
                        background: isDownstreamEdge ? 'rgba(3, 102, 214, 0.1)' : 'rgba(255, 255, 255, 0.95)',
                        padding: '2px 6px',
                        borderRadius: '3px',
                        border: isDownstreamEdge ? '1px solid #0366d6' : '1px solid #d1d5da',
                        boxShadow: isDownstreamEdge ? '0 2px 6px rgba(3,102,214,0.2)' : '0 1px 3px rgba(0,0,0,0.1)',
                        opacity: shouldDimEdge ? 0.6 : 1
                      },
                      labelBgPadding: [4, 2],
                      labelBgBorderRadius: 3,
                      data: {
                        elkEdgeData: true, // Mark this edge for ELK path lookup
                        hidden: !isEdgeVisible // Add hidden property for DOM stability
                      }
                    });

                    // Generate argument edges for this field (always enabled)
                    if (field.args && field.args.length > 0) {
                      field.args.forEach(arg => {
                        const argCoreTypeName = getCoreTypeName(arg.type);
                        const isArgRelationship = argCoreTypeName && !argCoreTypeName.startsWith('__') && !isScalarType(argCoreTypeName);

                        if (isArgRelationship) {
                          const targetTypeId = `type-${argCoreTypeName}`;
                          const edgeId = `${typeNodeId}-arg-${field.name}-${arg.name}`;

                          // Check if target type is visible
                          const isTargetVisible = visibleTypeNames.has(argCoreTypeName);
                          const isEdgeVisible = isSourceVisible && isTargetVisible;

                          edges.push({
                            id: edgeId,
                            source: typeNodeId,
                            target: targetTypeId,
                            sourceHandle: `${typeNodeId}-arg-${field.name}-${arg.name}`,
                            targetHandle: `${targetTypeId}-target`,
                            type: 'elk',
                            animated: false,
                            style: {
                              stroke: '#9ca3af', // Grey to match non-highlighted state
                              strokeWidth: 1,
                              strokeDasharray: '3,3', // Dashed line to distinguish from field edges
                              opacity: 0.6 // Higher opacity for better visibility
                            },
                            markerEnd: {
                              type: 'arrowclosed',
                              color: '#9ca3af', // Grey for arrow
                              width: 10,
                              height: 10
                            },
                            label: `${field.name}.${arg.name}`,
                            labelStyle: {
                              fontSize: '9px',
                              color: '#7c9eff',
                              background: 'rgba(124, 158, 255, 0.1)',
                              padding: '1px 4px',
                              borderRadius: '2px',
                              border: '1px solid #7c9eff',
                              opacity: 0.8
                            },
                            labelBgPadding: [2, 1],
                            labelBgBorderRadius: 2,
                            data: {
                              elkEdgeData: true,
                              isArgumentEdge: true,
                              hidden: !isEdgeVisible
                            }
                          });

                        }
                      });
                    }
                  }
                });
              }
            });

            return { nodes, edges };
          };

          if (loading) {
            return React.createElement('div', {
              style: {
                height: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                fontSize: '14px',
                color: '#666'
              }
            }, React.createElement('div', { key: 'loading-text' }, 'Loading schema...'));
          }

          if (error) {
            return React.createElement('div', {
              style: {
                height: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                fontSize: '14px',
                color: '#d73a49',
                textAlign: 'center',
                padding: '20px'
              }
            }, `Error: ${error}`);
          }

          // Remove this line since we're using state now
          // const { nodes, edges } = layoutedData;


          return React.createElement('div', {
            style: {
              padding: '0px',
              height: '100%',
              display: 'flex',
              flexDirection: 'column',
              gap: '16px',
              background: 'white'
            }
          }, [
            // Title
            React.createElement('h3', {
              key: 'title',
              style: {
                margin: '0 0 4px 0',
                fontSize: '29px',
                fontWeight: 'bold'
              }
            }, 'Graph Visualizer'),
            React.createElement('p', {
              key: 'description',
              className: 'graphiql-markdown-description',
              style: {
                margin: '0 0 20px 0',
                color: 'rgba(59, 75, 104, 0.76)'
              }
            }, 'Explore your GraphQL schema with an interactive visual graph.'),

            // Main visualization container
            React.createElement('div', {
              key: 'visualizer-container',
              className: 'schema-visualizer',
              style: {
                position: 'relative',
                width: '100%',
                flex: 1,
                minHeight: 0
              }
            }, [
            // Loading indicator when graph is hidden
            !graphVisible && React.createElement('div', {
              key: 'loading-indicator',
              style: {
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                color: '#656d76',
                fontSize: '16px',
                fontFamily: 'SF Pro Display, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                opacity: 0.7,
                zIndex: 1000
              }
            }, 'Loading schema visualization...'),

            // React Flow with our custom graph as a single node
            React.createElement(ReactFlow, {
              key: 'react-flow',
              nodes: [{
                id: 'graph-container',
                type: 'graphVisualization',
                position: { x: 0, y: 0 },
                // Set node dimensions to accommodate all content
                style: {
                  width: '3000px',
                  height: '4000px',
                  minWidth: '3000px',
                  minHeight: '4000px'
                },
                data: {
                  nodes,
                  edges,
                  selectedNodeId,
                  setSelectedNodeId,
                  onNodeClick,
                  onNodeDoubleClick,
                  onFieldClick,
                  showELKDebug,
                  elkDebugData,
                  showArgumentEdges,
                  edgesFading,
                  setGraphVisible,
                  // Add container dimensions to data for the custom node component
                  containerWidth: 3000,
                  containerHeight: 4000
                },
                draggable: false,
                selectable: false
              }],
              edges: [], // No React Flow edges, we handle them internally
              nodeTypes,
              fitView: true,
              fitViewOptions: {
                padding: 0.08, // Reduced padding to account for container margins
                duration: 400 // Faster initial fit view
              },
              defaultViewport: { x: 0, y: 0, zoom: 0.8 },
              minZoom: 0.1,
              maxZoom: 2,
              zoomOnDoubleClick: false, // Disable React Flow's double-click zoom
              panOnDrag: true, // Enable normal left-click panning
              nodeDragThreshold: 15, // Require 15px movement before considering it a drag
              selectionOnDrag: false, // Disable selection box on drag
              zoomOnScroll: true,
              onPaneClick,
              zoomActivationKeyCode: null, // Disable zoom activation key
              deleteKeyCode: null, // Disable delete key
              selectionKeyCode: null, // Disable selection key
              multiSelectionKeyCode: null, // Disable multi-selection key
              translateExtent: [[-Infinity, -Infinity], [Infinity, Infinity]],
              nodeExtent: [[-Infinity, -Infinity], [Infinity, Infinity]],
              style: {
                background: '#fafbfc',
                opacity: graphVisible ? 1 : 0,
                transition: 'opacity 0.6s ease-in-out'
              }
            }, [
              // Custom smooth controls positioned in bottom-left
              React.createElement('div', {
                key: 'custom-controls',
                style: {
                  position: 'absolute',
                  bottom: '20px',
                  left: '20px',
                  zIndex: 1000,
                  display: 'flex',
                  flexDirection: 'column',
                  gap: '4px'
                }
              }, [
                // Zoom In Button
                React.createElement('button', {
                  key: 'zoom-in',
                  onClick: () => {
                    if (window._smoothZoomIn) {
                      window._smoothZoomIn();
                    }
                  },
                  style: {
                    width: '40px',
                    height: '40px',
                    border: '1px solid #d1d5da',
                    borderRadius: '4px',
                    background: 'rgba(255, 255, 255, 0.95)',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    fontSize: '16px',
                    fontWeight: 'bold',
                    color: '#24292e',
                    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)',
                    transition: 'all 0.2s ease'
                  },
                  onMouseEnter: (e) => {
                    e.target.style.background = 'rgba(225, 228, 232, 0.95)';
                  },
                  onMouseLeave: (e) => {
                    e.target.style.background = 'rgba(255, 255, 255, 0.95)';
                  }
                }, '+'),

                // Zoom Out Button
                React.createElement('button', {
                  key: 'zoom-out',
                  onClick: () => {
                    if (window._smoothZoomOut) {
                      window._smoothZoomOut();
                    }
                  },
                  style: {
                    width: '40px',
                    height: '40px',
                    border: '1px solid #d1d5da',
                    borderRadius: '4px',
                    background: 'rgba(255, 255, 255, 0.95)',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    fontSize: '16px',
                    fontWeight: 'bold',
                    color: '#24292e',
                    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)',
                    transition: 'all 0.2s ease'
                  },
                  onMouseEnter: (e) => {
                    e.target.style.background = 'rgba(225, 228, 232, 0.95)';
                  },
                  onMouseLeave: (e) => {
                    e.target.style.background = 'rgba(255, 255, 255, 0.95)';
                  }
                }, 'âˆ’'),

                // Fit View Button
                React.createElement('button', {
                  key: 'fit-view',
                  onClick: () => {
                    const now = Date.now();
                    const lastFitViewTime = window._lastFitViewClickTime || 0;
                    const timeSinceLastClick = now - lastFitViewTime;
                    window._lastFitViewClickTime = now;

                    // If clicked within 1 second, toggle between root types and full view
                    if (timeSinceLastClick < 1000) {
                      // Toggle between root types view and full view
                      const isCurrentlyRootView = window._isRootTypesView || false;

                      if (isCurrentlyRootView) {
                        // Currently showing root types, switch to full view
                        window._isRootTypesView = false;
                        // Clear any selection when fit view is clicked
                        if (setSelectedNodeId) {
                          setSelectedNodeId(null);
                        }
                        if (window._smoothFitView) {
                          window._smoothFitView();
                        }
                      } else {
                        // Currently showing full view, switch to root types
                        window._isRootTypesView = true;
                        if (window._centerOnRootTypes) {
                          window._centerOnRootTypes();
                        }
                      }
                    } else {
                      // Normal fitview behavior - go to full view
                      window._isRootTypesView = false;
                      // Clear any selection when fit view is clicked
                      if (setSelectedNodeId) {
                        setSelectedNodeId(null);
                      }
                      if (window._smoothFitView) {
                        window._smoothFitView();
                      }
                    }
                  },
                  style: {
                    width: '40px',
                    height: '40px',
                    border: '1px solid #d1d5da',
                    borderRadius: '4px',
                    background: 'rgba(255, 255, 255, 0.95)',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    fontSize: '14px',
                    color: '#24292e',
                    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)',
                    transition: 'all 0.2s ease'
                  },
                  onMouseEnter: (e) => {
                    e.target.style.background = 'rgba(225, 228, 232, 0.95)';
                  },
                  onMouseLeave: (e) => {
                    e.target.style.background = 'rgba(255, 255, 255, 0.95)';
                  }
                }, React.createElement('svg', {
                  width: '16',
                  height: '16',
                  viewBox: '0 0 16 16',
                  fill: 'currentColor'
                }, React.createElement('path', {
                  d: 'M2 2h3v2H3v2H1V3a1 1 0 0 1 1-1zm9 0h3a1 1 0 0 1 1 1v3h-2V4h-2V2zM3 11H1v3a1 1 0 0 0 1 1h3v-2H3v-2zm10 0v2h-2v2h3a1 1 0 0 0 1-1v-3h-2z'
                })))
              ])
            ]),

            // ELK Debug legend - positioned relative to viewport, not the custom node
            showELKDebug && React.createElement('div', {
              key: 'elk-legend-overlay',
              style: {
                position: 'absolute',
                top: '10px',
                left: '10px',
                background: 'rgba(255, 255, 255, 0.9)',
                border: '2px solid #ff0000',
                borderRadius: '4px',
                padding: '8px',
                fontSize: '11px',
                fontFamily: 'monospace',
                fontWeight: 'bold',
                pointerEvents: 'none',
                zIndex: 1100
              }
            }, [
              React.createElement('div', { key: 'title', style: { marginBottom: '4px', color: '#ff0000' } }, 'ELK DEBUG OVERLAY'),
              React.createElement('div', { key: 'nodes', style: { color: '#ff0000' } }, 'ðŸŸ¥ Red dashed: ELK nodes'),
              React.createElement('div', { key: 'edges', style: { color: '#00ff00' } }, 'ðŸŸ¢ Green dashed: ELK edges'),
              React.createElement('div', { key: 'focus', style: { color: '#ff8800' } }, 'ðŸŸ§ Orange dashed: Focus bounds (double-click)'),
              React.createElement('div', { key: 'target', style: { color: '#0066ff' } }, 'ðŸ”µ Blue: TARGET ports'),
              React.createElement('div', { key: 'rel', style: { color: '#ff6600' } }, 'ðŸŸ  Orange: REL ports'),
              React.createElement('div', { key: 'scalar', style: { color: '#9966ff' } }, 'ðŸŸ£ Purple: SCALAR ports'),
              React.createElement('div', { key: 'other', style: { color: '#cccccc' } }, 'âšª Gray: OTHER ports')
            ])
            ])
          ]);
        }
      };

      // ============================================
      // Settings Plugin - API Key & Model Configuration
      // ============================================

      // Fetch available Gemini models dynamically
      const fetchGeminiModels = async (apiKey) => {
        if (!apiKey) return [];

        // Check cache first
        const cacheKey = 'graphiql:gemini-models-cache';
        const cacheTimeKey = 'graphiql:gemini-models-cache-time';
        const cachedModels = localStorage.getItem(cacheKey);
        const cacheTime = localStorage.getItem(cacheTimeKey);

        // Use cache if less than 1 hour old
        if (cachedModels && cacheTime && (Date.now() - parseInt(cacheTime)) < 3600000) {
          try {
            return JSON.parse(cachedModels);
          } catch (e) {
            // Cache invalid, fetch fresh
          }
        }

        try {
          const response = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`
          );

          if (!response.ok) {
            throw new Error('Failed to fetch models');
          }

          const data = await response.json();
          const models = (data.models || [])
            .filter(model =>
              model.supportedGenerationMethods &&
              model.supportedGenerationMethods.includes('generateContent')
            )
            .map(model => ({
              id: model.name.replace('models/', ''),
              name: model.displayName || model.name.replace('models/', ''),
              description: model.description || ''
            }))
            .sort((a, b) => a.name.localeCompare(b.name));

          // Cache the results
          localStorage.setItem(cacheKey, JSON.stringify(models));
          localStorage.setItem(cacheTimeKey, Date.now().toString());

          return models;
        } catch (error) {
          console.error('Error fetching Gemini models:', error);
          return [];
        }
      };

      // ============================================
      // Query Generator Plugin - Main Interface
      // ============================================

      // Build schema context for AI prompt
      const buildSchemaContext = (schemaData) => {
        if (!schemaData || !schemaData.__schema) return 'Schema not available';

        const schema = schemaData.__schema;
        const types = schema.types.filter(t =>
          !t.name.startsWith('__') &&
          !['String', 'Int', 'Float', 'Boolean', 'ID'].includes(t.name)
        );

        let context = 'GraphQL Schema:\n\n';

        // Root types
        if (schema.queryType) {
          context += `Query Type: ${schema.queryType.name}\n`;
        }
        if (schema.mutationType) {
          context += `Mutation Type: ${schema.mutationType.name}\n`;
        }
        if (schema.subscriptionType) {
          context += `Subscription Type: ${schema.subscriptionType.name}\n`;
        }

        context += '\nTypes:\n';

        // Limit types to avoid token overflow
        types.slice(0, 40).forEach(type => {
          context += `\n${type.kind} ${type.name}`;
          if (type.description) {
            context += ` - ${type.description.substring(0, 80)}`;
          }

          const fields = type.fields || type.inputFields;
          if (fields && fields.length > 0) {
            context += '\n  Fields: ';
            context += fields.slice(0, 15).map(f => {
              let fieldStr = f.name;
              const typeName = f.type?.name || f.type?.ofType?.name || f.type?.ofType?.ofType?.name || 'Unknown';
              fieldStr += `: ${typeName}`;
              if (f.args && f.args.length > 0) {
                fieldStr += `(${f.args.map(a => a.name).join(', ')})`;
              }
              return fieldStr;
            }).join(', ');
            if (fields.length > 15) {
              context += `, ... (${fields.length - 15} more)`;
            }
          }

          if (type.enumValues) {
            context += '\n  Values: ' + type.enumValues.map(v => v.name).join(', ');
          }
        });

        if (types.length > 40) {
          context += `\n\n... and ${types.length - 40} more types`;
        }

        return context;
      };

      // Fetch schema data (cached within session only)
      const ensureSchemaLoaded = async () => {
        // Use session cache if available (cleared on page refresh)
        if (window._queryGeneratorSchemaData) {
          return window._queryGeneratorSchemaData;
        }

        // Fetch the schema using introspection
        const introspectionQuery = `
          query IntrospectionQuery {
            __schema {
              queryType { name }
              mutationType { name }
              subscriptionType { name }
              types {
                kind
                name
                description
                fields(includeDeprecated: true) {
                  name
                  description
                  args {
                    name
                    description
                    type {
                      kind
                      name
                      ofType {
                        kind
                        name
                        ofType {
                          kind
                          name
                          ofType {
                            kind
                            name
                          }
                        }
                      }
                    }
                    defaultValue
                  }
                  type {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                        ofType {
                          kind
                          name
                        }
                      }
                    }
                  }
                  isDeprecated
                  deprecationReason
                }
                inputFields {
                  name
                  description
                  type {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                  defaultValue
                }
                interfaces {
                  kind
                  name
                }
                enumValues(includeDeprecated: true) {
                  name
                  description
                  isDeprecated
                  deprecationReason
                }
                possibleTypes {
                  kind
                  name
                }
              }
              directives {
                name
                description
                locations
                args {
                  name
                  description
                  type {
                    kind
                    name
                    ofType {
                      kind
                      name
                    }
                  }
                  defaultValue
                }
              }
            }
          }
        `;

        const response = await fetch(window.location.pathname, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query: introspectionQuery })
        });

        if (!response.ok) {
          throw new Error('Failed to fetch schema');
        }

        const result = await response.json();
        if (result.errors) {
          throw new Error(result.errors[0].message);
        }

        window._queryGeneratorSchemaData = result.data;
        return result.data;
      };

      // Call Gemini API
      const callGeminiAPI = async (userMessage, currentQuery, currentVariables, currentHeaders, conversationHistory = []) => {
        const apiKey = getGeminiApiKey();
        const model = localStorage.getItem('graphiql:gemini-model') || 'gemini-2.0-flash';

        if (!apiKey) {
          throw new Error('API key not configured. Please go to Settings to add your Gemini API key.');
        }

        // Ensure schema is loaded (fetch if needed)
        const schemaData = await ensureSchemaLoaded();

        const schemaContext = buildSchemaContext(schemaData);

        const systemPrompt = `You are a GraphQL query assistant. You help users create and modify GraphQL queries, variables, and headers based on their natural language requests.

${schemaContext}

CURRENT STATE IN EDITOR:
Query:
${currentQuery || '(empty - no query yet)'}

Variables (JSON):
${currentVariables || '{}'}

Headers (JSON):
${currentHeaders || '{}'}

INSTRUCTIONS:
1. Generate valid GraphQL queries based on the schema provided
2. If the query requires variables, provide them as valid JSON
3. If authentication or custom headers are needed, provide them as valid JSON
4. If the user's request is clear, generate a complete query with any needed variables/headers
5. If you need clarification, ask specific questions
6. When modifying existing content, preserve the structure where possible
7. Always explain what you're doing
8. Keep your message responses concise and conversational - avoid long lists or excessive formatting
9. Use simple markdown sparingly: **bold** for emphasis, \`code\` for field names. Avoid headers, numbered lists, or complex formatting

RESPONSE FORMAT - You must respond with valid JSON:
{
  "type": "query" | "question" | "suggestion",
  "message": "Your explanation or question to the user",
  "query": "The complete GraphQL query (only if type is 'query' or 'suggestion')",
  "variables": "JSON string of variables (only if needed, e.g., {\"id\": \"123\"})",
  "headers": "JSON string of headers (only if needed, e.g., {\"Authorization\": \"Bearer token\"})",
  "options": ["option1", "option2"], // Optional: only include if asking a question with specific choices
  "suggestions": ["suggestion1", "suggestion2", "suggestion3", "suggestion4"], // REQUIRED: Always include 4 short (2-5 words) contextual follow-up suggestions
  "needsResults": true | false, // Set to true when you need to see the actual query results to provide analysis
  "isNewQuery": true | false, // Set to true when generating a completely new query (not modifying existing)
  "resultsSummary": "Short description of what you'll analyze when results come back" // Include when suggesting a query
}

IMPORTANT RULES:
1. Always include the "suggestions" array with 4 helpful follow-up actions. These MUST be contextual and follow on from the conversation - suggest logical next steps based on what the user just asked and what query is currently in the editor. For example, if the user just added a query for users, suggest adding fields, filtering, pagination, or related queries. Don't repeat generic suggestions.

2. Set "needsResults": true when:
   - The user asks you to "show me", "what are the results", "run this", or similar requests to see actual data
   - The user wants you to analyze, debug, or explain the actual returned data
   - You need to see the query output to provide meaningful analysis or recommendations
   When needsResults is true, the user can click "Run & Analyze" to execute the query and send results back to you.

3. Set "isNewQuery": true when:
   - The user asks for an entirely new query unrelated to what's in the editor
   - You're generating a query from scratch based on a new request
   - The query is completely different from the current editor content
   Set it to false (or omit) when modifying, improving, or building upon the existing query. When isNewQuery is true, the UI shows a simple "will replace editor content" notice instead of a line-by-line diff.

4. When analyzing query results:
   - Focus on explaining what the data shows - patterns, insights, potential issues
   - Do NOT suggest query modifications unless there's a clear reason (error in results, user asked for changes, obvious problem)
   - If you do suggest a modification, ALWAYS explain WHY in your message (e.g., "The results show X is null, this could be fixed by...")
   - If the query ran successfully and returned expected data, just analyze it - don't offer unsolicited "improvements"
   - Only include a "query" field in your response if you're actually suggesting a meaningful change

5. When suggesting a query, include "resultsSummary" - a short description (5-15 words) of what you'll look for when the results come back. Examples:
   - "Checking user permissions and role assignments"
   - "Looking at product inventory levels"
   - "Verifying the order status fields"
   - "Examining pagination and total count"

Examples:
- Query with variables: {"type": "query", "message": "Here's a query to fetch a user by ID:", "query": "query GetUser($id: ID!) { user(id: $id) { name email } }", "variables": "{\"id\": \"123\"}", "resultsSummary": "Checking user profile data", "suggestions": ["Add more fields", "Remove the variable", "Add pagination", "Filter by role"]}
- Simple query: {"type": "query", "message": "Here's a query to fetch all users:", "query": "{ users { id name } }", "resultsSummary": "Reviewing the list of users", "suggestions": ["Add email field", "Add pagination", "Filter by status", "Sort by name"]}
- Asking for clarification: {"type": "question", "message": "Which user ID would you like to look up?", "options": ["Let me enter an ID", "Show all users instead"], "suggestions": ["Show all users", "Search by email", "List recent users", "Count total users"]}
- Requesting to analyze results: {"type": "query", "message": "Here's the query. Click 'Run & Analyze' and I'll examine the results for you:", "query": "{ users { id name status } }", "needsResults": true, "resultsSummary": "Analysing user status distribution", "suggestions": ["Filter active users", "Sort by name", "Add email field", "Count users"]}`;

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

        // Build conversation contents - only include user and assistant messages with actual text content
        // Filter out error messages and system messages
        const contents = [];

        conversationHistory
          .filter(msg => {
            // Only include user and assistant messages
            if (msg.role !== 'user' && msg.role !== 'assistant') return false;
            // Must have content
            if (!msg.content || !msg.content.trim()) return false;
            // Filter out error messages from assistant
            if (msg.role === 'assistant' && msg.type === 'error') return false;
            // Filter out messages that are just error text
            if (msg.content.startsWith('Error:')) return false;
            return true;
          })
          .forEach(msg => {
            contents.push({
              role: msg.role === 'user' ? 'user' : 'model',
              parts: [{ text: String(msg.content) }]
            });
          });

        // Always add the new user message
        contents.push({ role: 'user', parts: [{ text: userMessage }] });

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            // Use systemInstruction to always provide schema context
            systemInstruction: {
              parts: [{ text: systemPrompt }]
            },
            contents: contents,
            generationConfig: {
              responseMimeType: 'application/json'
            }
          })
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error?.message || `API request failed: ${response.status}`);
        }

        const data = await response.json();
        const textContent = data.candidates?.[0]?.content?.parts?.[0]?.text;

        if (!textContent) {
          throw new Error('No response from AI');
        }

        try {
          return JSON.parse(textContent);
        } catch {
          // If JSON parsing fails, wrap in suggestion
          return {
            type: 'suggestion',
            message: textContent,
            query: null
          };
        }
      };

      // Get current query from GraphiQL
      const getCurrentQuery = () => {
        try {
          const tabState = JSON.parse(localStorage.getItem('graphiql:tabState') || '{}');
          if (tabState.tabs && tabState.tabs.length > 0) {
            const activeIndex = tabState.activeTabIndex || 0;
            return tabState.tabs[activeIndex]?.query || '';
          }
        } catch (e) {
          console.error('Error getting current query:', e);
        }
        return '';
      };

      // Set query in GraphiQL editor
      const setEditorQuery = (query) => {
        try {
          // Method 1: Find CodeMirror 6 view via React fiber
          const queryEditor = document.querySelector('.graphiql-query-editor');
          if (queryEditor) {
            const cmEditor = queryEditor.querySelector('.cm-editor');
            if (cmEditor) {
              // Look for view in React fiber keys
              const fiberKey = Object.keys(cmEditor).find(k => k.startsWith('__reactFiber') || k.startsWith('__reactInternalInstance'));
              if (fiberKey) {
                let fiber = cmEditor[fiberKey];
                // Walk up the fiber tree looking for CodeMirror view
                for (let i = 0; i < 20 && fiber; i++) {
                  if (fiber.stateNode?.view?.dispatch) {
                    fiber.stateNode.view.dispatch({
                      changes: { from: 0, to: fiber.stateNode.view.state.doc.length, insert: query }
                    });
                    console.log('Query applied via React fiber');
                    return;
                  }
                  if (fiber.memoizedProps?.view?.dispatch) {
                    fiber.memoizedProps.view.dispatch({
                      changes: { from: 0, to: fiber.memoizedProps.view.state.doc.length, insert: query }
                    });
                    console.log('Query applied via memoizedProps');
                    return;
                  }
                  fiber = fiber.return;
                }
              }

              // Method 2: Look for view on cmContent element
              const cmContent = cmEditor.querySelector('.cm-content');
              if (cmContent) {
                // CM6 sometimes stores view reference
                const contentFiberKey = Object.keys(cmContent).find(k => k.startsWith('__reactFiber'));
                if (contentFiberKey) {
                  let fiber = cmContent[contentFiberKey];
                  for (let i = 0; i < 10 && fiber; i++) {
                    const view = fiber.stateNode?.view || fiber.memoizedProps?.view;
                    if (view?.dispatch) {
                      view.dispatch({
                        changes: { from: 0, to: view.state.doc.length, insert: query }
                      });
                      console.log('Query applied via content fiber');
                      return;
                    }
                    fiber = fiber.return;
                  }
                }
              }
            }
          }

          // Method 3: Try to find global CodeMirror reference
          if (window.CodeMirror) {
            const editors = document.querySelectorAll('.cm-editor');
            for (const ed of editors) {
              if (ed.closest('.graphiql-query-editor') && ed.CodeMirror) {
                ed.CodeMirror.setValue(query);
                console.log('Query applied via global CodeMirror');
                return;
              }
            }
          }

          // Method 4: Clipboard approach - copy to clipboard and notify user
          navigator.clipboard.writeText(query).then(() => {
            console.log('Query copied to clipboard');
            // Also update localStorage
            const tabState = JSON.parse(localStorage.getItem('graphiql:tabState') || '{}');
            if (tabState.tabs && tabState.tabs.length > 0) {
              const activeIndex = tabState.activeTabIndex || 0;
              tabState.tabs[activeIndex].query = query;
              localStorage.setItem('graphiql:tabState', JSON.stringify(tabState));
            }
            alert('Query copied to clipboard! Paste (Cmd/Ctrl+V) into the editor, or refresh the page.');
          }).catch(() => {
            // Fallback if clipboard fails
            const tabState = JSON.parse(localStorage.getItem('graphiql:tabState') || '{}');
            if (tabState.tabs && tabState.tabs.length > 0) {
              const activeIndex = tabState.activeTabIndex || 0;
              tabState.tabs[activeIndex].query = query;
              localStorage.setItem('graphiql:tabState', JSON.stringify(tabState));
              alert('Query saved! Refresh the page to apply.');
            }
          });
        } catch (e) {
          console.error('Error setting query:', e);
        }
      };

      // Compute diff using LCS (Longest Common Subsequence) for better grouping
      const computeDiff = (original, suggested) => {
        const originalLines = (original || '').split('\n');
        const suggestedLines = (suggested || '').split('\n');

        // Build LCS table
        const m = originalLines.length;
        const n = suggestedLines.length;
        const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

        for (let i = 1; i <= m; i++) {
          for (let j = 1; j <= n; j++) {
            if (originalLines[i - 1] === suggestedLines[j - 1]) {
              dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
              dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
          }
        }

        // Backtrack to find the diff, grouping changes into hunks
        const result = [];
        let i = m, j = n;
        const tempResult = [];

        while (i > 0 || j > 0) {
          if (i > 0 && j > 0 && originalLines[i - 1] === suggestedLines[j - 1]) {
            tempResult.unshift({ type: 'unchanged', content: originalLines[i - 1] });
            i--;
            j--;
          } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
            tempResult.unshift({ type: 'added', content: suggestedLines[j - 1] });
            j--;
          } else if (i > 0) {
            tempResult.unshift({ type: 'removed', content: originalLines[i - 1] });
            i--;
          }
        }

        // Now group consecutive changes into hunks (removed block, then added block)
        let idx = 0;
        while (idx < tempResult.length) {
          const item = tempResult[idx];

          if (item.type === 'unchanged') {
            result.push(item);
            idx++;
          } else {
            // Collect consecutive changes into a hunk
            const removedLines = [];
            const addedLines = [];

            while (idx < tempResult.length && tempResult[idx].type !== 'unchanged') {
              if (tempResult[idx].type === 'removed') {
                removedLines.push(tempResult[idx]);
              } else {
                addedLines.push(tempResult[idx]);
              }
              idx++;
            }

            // Add all removed lines first, then all added lines
            result.push(...removedLines, ...addedLines);
          }
        }

        return result;
      };

      // Inline Diff Viewer Component
      const InlineDiffViewer = ({ originalQuery, suggestedQuery, onAccept, onReject, onAcceptAndRun }) => {
        const diff = computeDiff(originalQuery, suggestedQuery);

        return React.createElement('div', {
          style: {
            borderTop: '1px solid var(--color-border, #e1e4e8)',
            background: 'var(--color-base-bg, #f6f8fa)'
          }
        }, [
          // Diff Header
          React.createElement('div', {
            key: 'diff-header',
            style: {
              padding: '10px 16px',
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              borderBottom: '1px solid var(--color-border, #e1e4e8)'
            }
          }, [
            React.createElement('span', {
              key: 'diff-title',
              style: {
                fontSize: '12px',
                fontWeight: '600',
                color: 'var(--color-base)'
              }
            }, 'Suggested Changes'),

            React.createElement('div', {
              key: 'actions',
              style: { display: 'flex', gap: '8px' }
            }, [
              React.createElement('button', {
                key: 'reject-btn',
                onClick: onReject,
                style: {
                  padding: '5px 10px',
                  background: 'var(--color-base-bg, white)',
                  border: '1px solid var(--color-border, #d1d5da)',
                  borderRadius: '4px',
                  cursor: 'pointer',
                  fontSize: '11px',
                  color: 'var(--color-base)',
                  transition: 'all 0.15s ease'
                },
                onMouseEnter: (e) => {
                  e.target.style.background = '#ffeaea';
                  e.target.style.borderColor = '#d73a49';
                  e.target.style.color = '#d73a49';
                },
                onMouseLeave: (e) => {
                  e.target.style.background = 'var(--color-base-bg, white)';
                  e.target.style.borderColor = 'var(--color-border, #d1d5da)';
                  e.target.style.color = 'var(--color-base)';
                }
              }, 'Reject'),

              React.createElement('button', {
                key: 'accept-btn',
                onClick: onAccept,
                style: {
                  padding: '5px 10px',
                  background: 'var(--color-base-bg, white)',
                  border: '1px solid #28a745',
                  borderRadius: '4px',
                  cursor: 'pointer',
                  fontSize: '11px',
                  color: '#28a745',
                  transition: 'all 0.15s ease'
                },
                onMouseEnter: (e) => {
                  e.target.style.background = '#28a745';
                  e.target.style.color = 'white';
                },
                onMouseLeave: (e) => {
                  e.target.style.background = 'var(--color-base-bg, white)';
                  e.target.style.color = '#28a745';
                }
              }, 'Accept'),

              React.createElement('button', {
                key: 'accept-run-btn',
                onClick: onAcceptAndRun,
                style: {
                  padding: '5px 10px',
                  background: 'hsl(var(--color-primary))',
                  border: 'none',
                  borderRadius: '4px',
                  cursor: 'pointer',
                  fontSize: '11px',
                  color: 'white',
                  fontWeight: '500',
                  transition: 'all 0.15s ease'
                },
                onMouseEnter: (e) => {
                  e.target.style.opacity = '0.9';
                },
                onMouseLeave: (e) => {
                  e.target.style.opacity = '1';
                }
              }, 'Accept & Run â–¶')
            ])
          ]),

          // Diff Content
          React.createElement('div', {
            key: 'diff-content',
            style: {
              maxHeight: '180px',
              overflow: 'auto',
              padding: '8px 12px'
            }
          }, React.createElement('pre', {
            style: {
              margin: 0,
              fontFamily: 'SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace',
              fontSize: '12px',
              lineHeight: '1.5'
            }
          }, diff.map((line, idx) =>
            React.createElement('div', {
              key: idx,
              style: {
                padding: '1px 6px',
                marginLeft: '-6px',
                marginRight: '-6px',
                background: line.type === 'added' ? 'rgba(40, 167, 69, 0.15)' :
                            line.type === 'removed' ? 'rgba(215, 58, 73, 0.15)' : 'transparent',
                color: line.type === 'added' ? '#22863a' :
                       line.type === 'removed' ? '#cb2431' : 'var(--color-base)',
                textDecoration: line.type === 'removed' ? 'line-through' : 'none'
              }
            }, [
              React.createElement('span', {
                key: 'prefix',
                style: {
                  display: 'inline-block',
                  width: '14px',
                  color: line.type === 'added' ? '#22863a' :
                         line.type === 'removed' ? '#cb2431' : 'var(--color-alpha-tertiary, #959da5)',
                  userSelect: 'none'
                }
              }, line.type === 'added' ? '+' : line.type === 'removed' ? '-' : ' '),
              line.content || ' '
            ])
          )))
        ]);
      };

      // Simple markdown renderer for message content
      const renderMarkdown = (text) => {
        if (!text) return null;

        // Split by code blocks first to preserve them
        const parts = text.split(/(`[^`]+`)/g);

        return parts.map((part, index) => {
          // Inline code
          if (part.startsWith('`') && part.endsWith('`')) {
            return React.createElement('code', {
              key: index,
              style: {
                background: 'rgba(27, 31, 35, 0.05)',
                padding: '2px 5px',
                borderRadius: '3px',
                fontSize: '0.9em',
                fontFamily: 'SFMono-Regular, Consolas, monospace'
              }
            }, part.slice(1, -1));
          }

          // Process bold and other formatting
          const elements = [];
          let remaining = part;
          let keyCounter = 0;

          while (remaining.length > 0) {
            // Bold: **text**
            const boldMatch = remaining.match(/\*\*([^*]+)\*\*/);
            if (boldMatch) {
              const beforeBold = remaining.slice(0, boldMatch.index);
              if (beforeBold) {
                elements.push(React.createElement('span', { key: `${index}-${keyCounter++}` }, beforeBold));
              }
              elements.push(React.createElement('strong', { key: `${index}-${keyCounter++}` }, boldMatch[1]));
              remaining = remaining.slice(boldMatch.index + boldMatch[0].length);
              continue;
            }

            // No more matches, add remaining text
            elements.push(React.createElement('span', { key: `${index}-${keyCounter++}` }, remaining));
            break;
          }

          return elements.length === 1 ? elements[0] : React.createElement('span', { key: index }, elements);
        });
      };

      // Message Component with inline diff support
      const MessageComponent = ({ message, onOptionClick, showDiff, diffStatus, onAccept, onReject, onAcceptAndRun, onRunAndAnalyze }) => {
        const isUser = message.role === 'user';
        const isSystem = message.role === 'system';
        const isResultsFeedback = message.type === 'results-feedback';
        const isAnalyzingStatus = message.type === 'analyzing-status';
        const hasQueryData = (message.query || message.variables || message.headers) &&
                          (message.type === 'query' || message.type === 'suggestion');

        // Check if there are actual differences (not just re-suggesting same query)
        const hasActualDiffs = hasQueryData && (
          (message.query && (message.originalQuery || '').trim() !== (message.query || '').trim()) ||
          (message.variables && (message.originalVariables || '').trim() !== (message.variables || '').trim()) ||
          (message.headers && (message.originalHeaders || '').trim() !== (message.headers || '').trim())
        );

        // Has a query but no actual changes = suggesting to re-run the same query
        const isRerunSuggestion = hasQueryData && !hasActualDiffs;
        const hasChanges = hasQueryData;

        const isPending = diffStatus === 'pending';
        const isApplied = diffStatus === 'applied';
        const isDismissed = diffStatus === 'dismissed';
        const isAnalyzing = diffStatus === 'analyzing';

        // Checkbox states for Execute and Analyse options
        const [executeEnabled, setExecuteEnabled] = React.useState(true);
        const [analyseEnabled, setAnalyseEnabled] = React.useState(true);

        // Delayed text display for analyzing-status messages
        const [showDisplayText, setShowDisplayText] = React.useState(false);
        React.useEffect(() => {
          if (isAnalyzingStatus) {
            const timer = setTimeout(() => setShowDisplayText(true), 1000);
            return () => clearTimeout(timer);
          }
        }, [isAnalyzingStatus]);

        // Handler for the Apply button based on checkbox states
        const handleApply = () => {
          if (analyseEnabled && executeEnabled) {
            onRunAndAnalyze && onRunAndAnalyze();
          } else if (executeEnabled) {
            onAcceptAndRun && onAcceptAndRun();
          } else {
            onAccept && onAccept();
          }
        };

        // Helper to render a diff section - only if there are actual changes
        const renderDiffSection = (title, original, updated) => {
          if (!updated) return null;
          // Normalize for comparison (trim whitespace)
          const normalizedOriginal = (original || '').trim();
          const normalizedUpdated = (updated || '').trim();
          // Skip if no actual changes
          if (normalizedOriginal === normalizedUpdated) return null;
          const diff = computeDiff(original || '', updated);
          return React.createElement('div', {
            key: title,
            style: { marginBottom: '8px' }
          }, [
            React.createElement('div', {
              key: 'title',
              style: {
                fontSize: '10px',
                fontWeight: '600',
                color: 'var(--color-alpha-secondary, #586069)',
                marginBottom: '4px',
                textTransform: 'uppercase',
                letterSpacing: '0.5px'
              }
            }, title),
            React.createElement('div', {
              key: 'content',
              style: {
                background: 'var(--color-base-bg, white)',
                borderRadius: '4px',
                padding: '6px 8px',
                border: '1px solid var(--color-border, #e1e4e8)'
              }
            }, diff.map((line, idx) =>
              React.createElement('div', {
                key: idx,
                style: {
                  fontFamily: 'SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace',
                  fontSize: '11px',
                  lineHeight: '1.4',
                  background: line.type === 'added' ? 'rgba(40, 167, 69, 0.15)' :
                              line.type === 'removed' ? 'rgba(215, 58, 73, 0.15)' : 'transparent',
                  color: line.type === 'added' ? '#22863a' :
                         line.type === 'removed' ? '#cb2431' : 'var(--color-base)',
                  textDecoration: line.type === 'removed' ? 'line-through' : 'none',
                  padding: '1px 4px',
                  margin: '0 -4px'
                }
              }, [
                React.createElement('span', {
                  key: 'prefix',
                  style: {
                    display: 'inline-block',
                    width: '12px',
                    color: line.type === 'added' ? '#22863a' :
                           line.type === 'removed' ? '#cb2431' : '#959da5',
                    userSelect: 'none'
                  }
                }, line.type === 'added' ? '+' : line.type === 'removed' ? '-' : ' '),
                line.content || ' '
              ])
            ))
          ]);
        };

        return React.createElement('div', {
          style: {
            display: 'flex',
            flexDirection: 'column',
            alignItems: isUser ? 'flex-end' : 'flex-start',
            marginBottom: '8px'
          }
        }, [
          // Message bubble (for results-feedback, show a compact summary instead of full content)
          React.createElement('div', {
            key: 'bubble',
            style: {
              maxWidth: '85%',
              padding: '10px 14px',
              borderRadius: '12px',
              background: isUser ? '#e3f2fd' :
                          isSystem ? 'var(--color-base-bg, #f6f8fa)' :
                          isResultsFeedback ? '#f6f8fa' :
                          message.type === 'error' ? '#ffeaea' : 'var(--color-base-bg, #f1f3f5)',
              color: isUser ? '#1565c0' :
                     isResultsFeedback ? '#24292e' :
                     message.type === 'error' ? '#d73a49' : 'var(--color-base)',
              fontSize: '13px',
              lineHeight: '1.5',
              border: isResultsFeedback ? '1px solid #e1e4e8' : 'none'
            }
          }, [
            // For results-feedback, show only the Response Data expandable
            isResultsFeedback ? React.createElement('details', {
              key: 'payload',
              style: { fontSize: '12px' }
            }, [
              React.createElement('summary', {
                key: 'summary',
                style: {
                  cursor: 'pointer',
                  color: '#24292e',
                  userSelect: 'none'
                }
              }, 'Response Data'),

              React.createElement('div', {
                key: 'content',
                style: { marginTop: '8px' }
              }, [
                // Query section
                React.createElement('div', {
                  key: 'query-label',
                  style: { fontWeight: 500, marginBottom: '4px', fontSize: '10px', textTransform: 'uppercase', color: '#586069' }
                }, 'Query'),
                React.createElement('pre', {
                  key: 'query',
                  style: {
                    margin: '0 0 8px 0',
                    padding: '8px',
                    background: '#f6f8fa',
                    color: '#24292e',
                    borderRadius: '4px',
                    overflow: 'auto',
                    maxHeight: '120px',
                    fontSize: '10px',
                    fontFamily: 'SFMono-Regular, Consolas, monospace'
                  }
                }, message.payload?.query || ''),

                // Results section
                React.createElement('div', {
                  key: 'results-label',
                  style: { fontWeight: 500, marginBottom: '4px', fontSize: '10px', textTransform: 'uppercase', color: '#586069' }
                }, 'Results'),
                React.createElement('pre', {
                  key: 'results',
                  style: {
                    margin: 0,
                    padding: '8px',
                    background: '#f6f8fa',
                    color: '#24292e',
                    borderRadius: '4px',
                    overflow: 'auto',
                    maxHeight: '150px',
                    fontSize: '10px',
                    fontFamily: 'SFMono-Regular, Consolas, monospace'
                  }
                }, JSON.stringify(message.payload?.results, null, 2))
              ])
            ]) : isAnalyzingStatus ? React.createElement('div', {
              key: 'analyzing-content',
              style: {
                color: '#586069',
                fontStyle: showDisplayText ? 'normal' : 'italic'
              }
            }, showDisplayText
              ? (message.displayText || 'Analysing query results...')
              : 'Analysing...'
            ) : React.createElement('div', {
              key: 'content',
              style: {
                whiteSpace: 'pre-wrap'
              }
            }, renderMarkdown(message.content)),

            // Show options if present
            message.options && message.options.length > 0 && React.createElement('div', {
              key: 'options',
              style: {
                marginTop: '10px',
                display: 'flex',
                flexWrap: 'wrap',
                gap: '6px'
              }
            }, message.options.map((option, idx) =>
              React.createElement('button', {
                key: idx,
                type: 'button',
                onClick: (e) => { e.preventDefault(); onOptionClick && onOptionClick(option); },
                style: {
                  padding: '4px 10px',
                  background: 'white',
                  border: '1px solid var(--color-border, #d1d5da)',
                  borderRadius: '12px',
                  fontSize: '11px',
                  cursor: 'pointer',
                  color: 'var(--color-base)',
                  transition: 'all 0.15s ease'
                },
                onMouseEnter: (e) => {
                  e.target.style.background = 'hsl(var(--color-primary))';
                  e.target.style.color = 'white';
                  e.target.style.borderColor = 'hsl(var(--color-primary))';
                },
                onMouseLeave: (e) => {
                  e.target.style.background = 'white';
                  e.target.style.color = 'var(--color-base)';
                  e.target.style.borderColor = 'var(--color-border, #d1d5da)';
                }
              }, option)
            ))
          ]),

          // Inline diff viewer for messages with changes
          showDiff && hasChanges && React.createElement('div', {
            key: 'inline-diff',
            style: {
              marginTop: '8px',
              width: '100%',
              maxWidth: '95%',
              background: 'var(--color-base-bg, #f6f8fa)',
              border: `1px solid ${isApplied ? '#28a745' : isDismissed ? '#d73a49' : 'var(--color-border, #e1e4e8)'}`,
              borderRadius: '8px',
              overflow: 'hidden',
              opacity: isDismissed ? 0.6 : 1
            }
          }, [
            // Status header for applied/dismissed
            (isApplied || isDismissed) && React.createElement('div', {
              key: 'status-header',
              style: {
                padding: '6px 12px',
                background: isApplied ? 'rgba(40, 167, 69, 0.1)' : 'rgba(215, 58, 73, 0.1)',
                borderBottom: '1px solid var(--color-border, #e1e4e8)',
                fontSize: '11px',
                fontWeight: '500',
                color: isApplied ? '#28a745' : '#d73a49'
              }
            }, isApplied ? 'âœ“ Applied to editor' : 'âœ— Dismissed'),

            // New Query notice (simplified view without diff)
            message.isNewQuery && !isApplied && !isDismissed && React.createElement('div', {
              key: 'new-query-notice',
              style: {
                padding: '10px 12px',
                background: '#f0f7ff',
                borderBottom: '1px solid var(--color-border, #e1e4e8)',
                fontSize: '12px'
              }
            }, [
              React.createElement('div', {
                key: 'title',
                style: { fontWeight: '500', marginBottom: '4px', color: '#0969da' }
              }, 'New Query'),
              React.createElement('div', {
                key: 'subtitle',
                style: { fontSize: '11px', color: '#57606a' }
              }, 'Applying will replace the current editor content')
            ]),

            // Diff content - Query, Variables, Headers (skip diff for new queries, just show preview)
            React.createElement('div', {
              key: 'diff-content',
              style: {
                maxHeight: '300px',
                overflow: 'auto',
                padding: '10px 12px'
              }
            }, message.isNewQuery ? [
              // For new queries, just show the query preview (no diff)
              message.query && React.createElement('div', { key: 'query-preview' }, [
                React.createElement('div', {
                  key: 'label',
                  style: { fontSize: '10px', fontWeight: '600', color: '#57606a', marginBottom: '4px', textTransform: 'uppercase' }
                }, 'Query'),
                React.createElement('pre', {
                  key: 'content',
                  style: {
                    margin: 0,
                    padding: '8px',
                    background: '#f6f8fa',
                    borderRadius: '4px',
                    fontSize: '11px',
                    fontFamily: 'SFMono-Regular, Consolas, monospace',
                    whiteSpace: 'pre-wrap',
                    wordBreak: 'break-word',
                    maxHeight: '150px',
                    overflow: 'auto'
                  }
                }, message.query)
              ]),
              message.variables && message.variables !== '{}' && React.createElement('div', { key: 'vars-preview', style: { marginTop: '8px' } }, [
                React.createElement('div', {
                  key: 'label',
                  style: { fontSize: '10px', fontWeight: '600', color: '#57606a', marginBottom: '4px', textTransform: 'uppercase' }
                }, 'Variables'),
                React.createElement('pre', {
                  key: 'content',
                  style: {
                    margin: 0,
                    padding: '8px',
                    background: '#f6f8fa',
                    borderRadius: '4px',
                    fontSize: '11px',
                    fontFamily: 'SFMono-Regular, Consolas, monospace',
                    whiteSpace: 'pre-wrap'
                  }
                }, message.variables)
              ])
            ].filter(Boolean) : isRerunSuggestion ? [
              // No changes - just suggesting to re-run the current query
              React.createElement('div', {
                key: 'rerun-message',
                style: {
                  padding: '8px 12px',
                  fontSize: '12px',
                  color: 'var(--color-alpha-secondary, #586069)',
                  fontStyle: 'italic',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '6px'
                }
              }, [
                React.createElement('span', { key: 'icon' }, 'â–¶'),
                'No changes to apply â€” run current query'
              ])
            ] : [
              // For modified queries, show the diff
              renderDiffSection('Query', message.originalQuery, message.query),
              renderDiffSection('Variables', message.originalVariables, message.variables),
              renderDiffSection('Headers', message.originalHeaders, message.headers)
            ].filter(Boolean)),

            // Action buttons - show for pending and applied (allows reapply)
            (isPending || isApplied) && React.createElement('div', {
              key: 'actions',
              style: {
                padding: '8px 12px',
                borderTop: '1px solid var(--color-border, #e1e4e8)',
                display: 'flex',
                gap: '12px',
                alignItems: 'center',
                justifyContent: 'flex-end',
                flexWrap: 'wrap'
              }
            }, isRerunSuggestion ? [
              // Simplified actions for re-run
              isPending && React.createElement('button', {
                key: 'dismiss',
                type: 'button',
                onClick: (e) => { e.preventDefault(); onReject && onReject(); },
                style: {
                  padding: '5px 10px',
                  background: 'var(--color-base-bg, white)',
                  border: '1px solid var(--color-border, #d1d5da)',
                  borderRadius: '4px',
                  cursor: 'pointer',
                  fontSize: '11px',
                  color: 'var(--color-base)'
                }
              }, 'Dismiss'),
              React.createElement('div', { key: 'spacer', style: { flex: 1 } }),
              // Analyse checkbox for re-run
              React.createElement('label', {
                key: 'analyse-label',
                style: {
                  display: 'flex',
                  alignItems: 'center',
                  gap: '4px',
                  fontSize: '11px',
                  color: 'var(--color-alpha-secondary, #586069)',
                  cursor: 'pointer',
                  userSelect: 'none'
                }
              }, [
                React.createElement('input', {
                  key: 'analyse-checkbox',
                  type: 'checkbox',
                  checked: analyseEnabled,
                  onChange: (e) => setAnalyseEnabled(e.target.checked),
                  style: { margin: 0, cursor: 'pointer' }
                }),
                'Analyse Response'
              ]),
              React.createElement('button', {
                key: 'execute',
                type: 'button',
                onClick: (e) => {
                  e.preventDefault();
                  if (analyseEnabled) {
                    onRunAndAnalyze && onRunAndAnalyze();
                  } else {
                    onAcceptAndRun && onAcceptAndRun();
                  }
                },
                style: {
                  padding: '5px 12px',
                  background: '#28a745',
                  border: 'none',
                  borderRadius: '4px',
                  cursor: 'pointer',
                  fontSize: '11px',
                  fontWeight: '500',
                  color: 'white'
                }
              }, 'Execute Query')
            ] : [
              // Dismiss button - only show when pending (can't dismiss what's already applied)
              isPending && React.createElement('button', {
                key: 'reject',
                type: 'button',
                onClick: (e) => { e.preventDefault(); onReject && onReject(); },
                style: {
                  padding: '5px 10px',
                  background: 'var(--color-base-bg, white)',
                  border: '1px solid var(--color-border, #d1d5da)',
                  borderRadius: '4px',
                  cursor: 'pointer',
                  fontSize: '11px',
                  color: 'var(--color-base)'
                }
              }, 'Dismiss'),

              // Spacer to push checkboxes and button to the right
              React.createElement('div', { key: 'spacer', style: { flex: 1 } }),

              // Execute checkbox
              React.createElement('label', {
                key: 'execute-label',
                style: {
                  display: 'flex',
                  alignItems: 'center',
                  gap: '4px',
                  fontSize: '11px',
                  color: 'var(--color-alpha-secondary, #586069)',
                  cursor: 'pointer',
                  userSelect: 'none'
                }
              }, [
                React.createElement('input', {
                  key: 'execute-checkbox',
                  type: 'checkbox',
                  checked: executeEnabled,
                  onChange: (e) => {
                    setExecuteEnabled(e.target.checked);
                    // If execute is unchecked, also uncheck analyse
                    if (!e.target.checked) setAnalyseEnabled(false);
                  },
                  style: { margin: 0, cursor: 'pointer' }
                }),
                'Execute Query'
              ]),

              // Analyse checkbox
              React.createElement('label', {
                key: 'analyse-label',
                style: {
                  display: 'flex',
                  alignItems: 'center',
                  gap: '4px',
                  fontSize: '11px',
                  color: executeEnabled ? 'var(--color-alpha-secondary, #586069)' : 'var(--color-border, #d1d5da)',
                  cursor: executeEnabled ? 'pointer' : 'not-allowed',
                  userSelect: 'none'
                }
              }, [
                React.createElement('input', {
                  key: 'analyse-checkbox',
                  type: 'checkbox',
                  checked: analyseEnabled,
                  disabled: !executeEnabled,
                  onChange: (e) => setAnalyseEnabled(e.target.checked),
                  style: { margin: 0, cursor: executeEnabled ? 'pointer' : 'not-allowed' }
                }),
                'Analyse Response'
              ]),

              // Single Accept button
              React.createElement('button', {
                key: 'accept',
                type: 'button',
                onClick: (e) => { e.preventDefault(); handleApply(); },
                style: {
                  padding: '5px 12px',
                  background: 'var(--color-base-bg, white)',
                  border: '1px solid #28a745',
                  borderRadius: '4px',
                  cursor: 'pointer',
                  fontSize: '11px',
                  color: '#28a745',
                  fontWeight: '500'
                }
              }, 'Accept')
            ].filter(Boolean)),

            // Analyzing indicator - show when running query for analysis
            isAnalyzing && React.createElement('div', {
              key: 'analyzing',
              style: {
                padding: '8px 12px',
                borderTop: '1px solid var(--color-border, #e1e4e8)',
                display: 'flex',
                alignItems: 'center',
                gap: '8px',
                fontSize: '11px',
                color: 'var(--color-alpha-secondary, #586069)'
              }
            }, [
              React.createElement('span', {
                key: 'spinner',
                style: {
                  display: 'inline-block'
                }
              }, 'â³'),
              'Running query and analysing results...'
            ]),

            // Results analyzed badge - show after analysis complete
            message.resultsAnalyzed && !isAnalyzing && React.createElement('div', {
              key: 'analyzed-badge',
              style: {
                padding: '6px 12px',
                borderTop: '1px solid var(--color-border, #e1e4e8)',
                display: 'flex',
                alignItems: 'center',
                gap: '6px',
                fontSize: '11px',
                color: 'var(--color-alpha-secondary, #586069)'
              }
            }, [
              React.createElement('span', { key: 'icon' }, 'âœ“'),
              'Results analysed'
            ])
          ])
        ]);
      };

      // Settings Popup Content Component (for Query Generator)
      const SettingsPopupContent = ({ onClose }) => {
        const originalApiKey = React.useRef(localStorage.getItem('graphiql:gemini-api-key') || '');
        const [apiKey, setApiKey] = React.useState(originalApiKey.current);
        const [showApiKey, setShowApiKey] = React.useState(false);
        const [selectedModel, setSelectedModel] = React.useState(() =>
          localStorage.getItem('graphiql:gemini-model') || ''
        );
        const [persistChat, setPersistChat] = React.useState(() =>
          localStorage.getItem('graphiql:persist-chat') !== 'false' // default true
        );
        const [models, setModels] = React.useState([]);
        const [loadingModels, setLoadingModels] = React.useState(false);
        const [apiKeySaveStatus, setApiKeySaveStatus] = React.useState(null);
        const lastFetchedKeyRef = React.useRef(null);

        // Check if API key has been modified
        const apiKeyChanged = apiKey !== originalApiKey.current;

        const loadModels = React.useCallback(async (key) => {
          if (!key) {
            setModels([]);
            return;
          }
          // Don't refetch if we already fetched for this key
          if (lastFetchedKeyRef.current === key && models.length > 0) {
            return;
          }
          setLoadingModels(true);
          try {
            const fetchedModels = await fetchGeminiModels(key);
            setModels(fetchedModels);
            lastFetchedKeyRef.current = key;
            if (fetchedModels.length > 0 && !selectedModel) {
              const defaultModel = fetchedModels.find(m => m.id.includes('flash')) || fetchedModels[0];
              setSelectedModel(defaultModel.id);
            }
          } catch (err) {
            console.error('Failed to fetch models:', err);
            setModels([]);
          } finally {
            setLoadingModels(false);
          }
        }, [selectedModel, models.length]);

        // Auto-fetch models when API key changes (debounced)
        React.useEffect(() => {
          if (!apiKey || apiKey.length < 10) return; // Don't fetch for very short keys

          const timer = setTimeout(() => {
            loadModels(apiKey);
          }, 500); // 500ms debounce

          return () => clearTimeout(timer);
        }, [apiKey]);

        // Initial load on mount
        React.useEffect(() => {
          if (apiKey) loadModels(apiKey);
        }, []);

        // Save API key only
        const handleSaveApiKey = () => {
          localStorage.setItem('graphiql:gemini-api-key', apiKey);
          originalApiKey.current = apiKey;
          setApiKeySaveStatus('saved');
          setTimeout(() => setApiKeySaveStatus(null), 1500);
        };

        // Auto-save model when changed
        const handleModelChange = (newModel) => {
          setSelectedModel(newModel);
          localStorage.setItem('graphiql:gemini-model', newModel);
        };

        // Auto-save persist chat when changed
        const handlePersistChatChange = (enabled) => {
          setPersistChat(enabled);
          localStorage.setItem('graphiql:persist-chat', enabled ? 'true' : 'false');
          if (!enabled) {
            localStorage.removeItem('graphiql:chat-messages');
          }
        };

        return React.createElement(React.Fragment, null, [
          // Header (using native GraphiQL classes)
          React.createElement('div', {
            key: 'header',
            className: 'graphiql-dialog-header'
          }, [
            React.createElement('h2', {
              key: 'title',
              className: 'graphiql-dialog-title'
            }, 'Query Generator Settings'),
            React.createElement('button', {
              key: 'close',
              onClick: onClose,
              type: 'button',
              'aria-label': 'Close dialog',
              style: {
                position: 'absolute',
                top: '21px',
                right: '21px',
                background: '#ffffff',
                border: '2px solid #e0e0e0',
                cursor: 'pointer',
                width: '38px',
                height: '38px',
                borderRadius: '6px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                color: '#5c6370',
                fontSize: '24px',
                lineHeight: 0,
                fontWeight: '300',
                paddingBottom: '2px'
              },
              onMouseEnter: (e) => e.currentTarget.style.background = '#f5f5f5',
              onMouseLeave: (e) => e.currentTarget.style.background = '#ffffff'
            }, 'Ã—')
          ]),

          // API Key Section (using native GraphiQL classes)
          React.createElement('div', { key: 'api-key-section', className: 'graphiql-dialog-section' }, [
            React.createElement('div', { key: 'info' }, [
              React.createElement('div', { key: 'title', className: 'graphiql-dialog-section-title' }, 'Gemini API Key'),
              React.createElement('div', { key: 'caption', className: 'graphiql-dialog-section-caption' }, 'Enter your Google AI Studio API key to enable the query generator.')
            ]),
            React.createElement('div', { key: 'input-row', style: { display: 'flex', gap: '8px' } }, [
              React.createElement('input', {
                key: 'input',
                type: showApiKey ? 'text' : 'password',
                value: apiKey,
                onChange: (e) => setApiKey(e.target.value),
                placeholder: 'Enter API key',
                className: 'graphiql-button',
                style: {
                  flex: 1,
                  fontFamily: 'monospace',
                  textAlign: 'left'
                }
              }),
              // Show/Hide button transforms to Save button when API key is edited
              React.createElement('button', {
                key: 'action-btn',
                onClick: apiKeyChanged ? handleSaveApiKey : () => setShowApiKey(!showApiKey),
                type: 'button',
                className: 'graphiql-button',
                style: { minWidth: '70px' }
              }, apiKeyChanged ? (apiKeySaveStatus === 'saved' ? 'Saved!' : 'Save') : (showApiKey ? 'Hide' : 'Show'))
            ])
          ]),

          // Model selector Section (using native GraphiQL classes) - auto-saves
          React.createElement('div', { key: 'model-section', className: 'graphiql-dialog-section' }, [
            React.createElement('div', { key: 'info' }, [
              React.createElement('div', { key: 'title', className: 'graphiql-dialog-section-title' }, 'Model'),
              React.createElement('div', { key: 'caption', className: 'graphiql-dialog-section-caption' }, 'Select the Gemini model to use for generating queries.')
            ]),
            models.length > 0 ?
              React.createElement('select', {
                key: 'select',
                value: selectedModel,
                onChange: (e) => handleModelChange(e.target.value),
                className: 'graphiql-button',
                style: { cursor: 'pointer' }
              }, models.map(m => React.createElement('option', { key: m.id, value: m.id }, m.name)))
            :
              React.createElement('div', {
                key: 'no-models',
                className: 'graphiql-dialog-section-caption'
              }, loadingModels ? 'Loading models...' : (apiKey ? 'No models found' : 'Enter API key to load models'))
          ]),

          // Persist chat toggle Section (using native GraphiQL classes) - auto-saves
          React.createElement('div', { key: 'persist-section', className: 'graphiql-dialog-section' }, [
            React.createElement('div', { key: 'info' }, [
              React.createElement('div', { key: 'title', className: 'graphiql-dialog-section-title' }, 'Chat History'),
              React.createElement('div', { key: 'caption', className: 'graphiql-dialog-section-caption' }, 'Persist chat history between sessions.')
            ]),
            React.createElement('div', { key: 'buttons', className: 'graphiql-button-group' }, [
              React.createElement('button', {
                key: 'on',
                type: 'button',
                className: persistChat ? 'graphiql-button active' : 'graphiql-button',
                onClick: () => handlePersistChatChange(true)
              }, 'On'),
              React.createElement('button', {
                key: 'off',
                type: 'button',
                className: !persistChat ? 'graphiql-button active' : 'graphiql-button',
                onClick: () => handlePersistChatChange(false)
              }, 'Off')
            ])
          ])
        ]);
      };

      // Helper to execute a GraphQL query and get results
      const executeQueryAndGetResults = async (query, variables, headers) => {
        const params = new URLSearchParams(window.location.search);
        const fetchURL = '?' + params.toString();

        const parsedHeaders = headers ? (typeof headers === 'string' ? JSON.parse(headers) : headers) : {};
        const parsedVariables = variables ? (typeof variables === 'string' ? JSON.parse(variables) : variables) : undefined;

        const response = await fetch(fetchURL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...parsedHeaders
          },
          body: JSON.stringify({
            query,
            variables: parsedVariables
          })
        });

        return await response.json();
      };

      // Global state for Query Generator (persists across panel switches)
      if (!window._queryGeneratorState) {
        // Load persisted messages if enabled
        const persistEnabled = localStorage.getItem('graphiql:persist-chat') !== 'false'; // default true
        let savedMessages = [];
        if (persistEnabled) {
          try {
            savedMessages = JSON.parse(localStorage.getItem('graphiql:chat-messages') || '[]');
          } catch (e) {
            savedMessages = [];
          }
        }
        window._queryGeneratorState = {
          messages: savedMessages
        };
      }

      // Query Generator Panel Component
      const QueryGeneratorPanel = () => {
        // Use GraphiQL's editor context to access the query editor
        const editorContext = useEditorContext();
        const [messages, setMessages] = React.useState(() => window._queryGeneratorState.messages || []);
        const [inputValue, setInputValue] = React.useState('');
        const [isLoading, setIsLoading] = React.useState(false);
        const [error, setError] = React.useState(null);
        const [showSettings, setShowSettings] = React.useState(false);
        const [suggestions, setSuggestions] = React.useState(() =>
          window._queryGeneratorState.suggestions || ['Show all queries', 'List types', 'Help me build a query']
        );
        const [loadingSuggestions, setLoadingSuggestions] = React.useState(false);
        const messagesContainerRef = React.useRef(null);
        const settingsRef = React.useRef(null);
        const settingsBtnRef = React.useRef(null);

        // Helper to get value from a CodeMirror editor
        const getEditorValue = (editor) => {
          if (!editor) return '';
          if (editor.getValue) return editor.getValue();
          if (editor.state?.doc) return editor.state.doc.toString();
          return '';
        };

        // Helper to set value in a CodeMirror editor
        const setEditorValue = (editor, value) => {
          if (!editor) return false;
          if (editor.setValue) {
            editor.setValue(value);
            return true;
          }
          if (editor.dispatch && editor.state) {
            editor.dispatch({
              changes: { from: 0, to: editor.state.doc.length, insert: value }
            });
            return true;
          }
          return false;
        };

        // Function to get current state from GraphiQL's editor context
        const getEditorState = React.useCallback(() => {
          const query = getEditorValue(editorContext?.queryEditor) || getCurrentQuery();
          const variables = getEditorValue(editorContext?.variableEditor) || '{}';
          const headers = getEditorValue(editorContext?.headerEditor) || '{}';
          return { query, variables, headers };
        }, [editorContext]);

        // Function to set query, variables, and headers using GraphiQL's editor context
        const setEditorState = React.useCallback(({ query, variables, headers }) => {
          console.log('setEditorState called', { query, variables, headers });

          // Set query
          if (query !== undefined && query !== null) {
            if (!setEditorValue(editorContext?.queryEditor, query)) {
              setEditorQuery(query); // Fallback
            }
          }

          // Set variables
          if (variables !== undefined && variables !== null) {
            const varsStr = typeof variables === 'string' ? variables : JSON.stringify(variables, null, 2);
            if (!setEditorValue(editorContext?.variableEditor, varsStr)) {
              console.log('Could not set variables via editor context');
            }
          }

          // Set headers
          if (headers !== undefined && headers !== null) {
            const headersStr = typeof headers === 'string' ? headers : JSON.stringify(headers, null, 2);
            if (!setEditorValue(editorContext?.headerEditor, headersStr)) {
              console.log('Could not set headers via editor context');
            }
          }
        }, [editorContext]);

        // Sync messages to global state and localStorage
        React.useEffect(() => {
          window._queryGeneratorState.messages = messages;
          // Persist to localStorage if enabled
          const persistEnabled = localStorage.getItem('graphiql:persist-chat') !== 'false';
          if (persistEnabled && messages.length > 0) {
            localStorage.setItem('graphiql:chat-messages', JSON.stringify(messages));
          }
        }, [messages]);

        // Sync suggestions to global state
        React.useEffect(() => {
          window._queryGeneratorState.suggestions = suggestions;
        }, [suggestions]);

        // Fetch initial suggestions based on schema (only used on first load)
        const fetchInitialSuggestions = React.useCallback(async () => {
          const apiKey = getGeminiApiKey();
          if (!apiKey) return;

          setLoadingSuggestions(true);
          try {
            const schemaData = await ensureSchemaLoaded();
            const schemaContext = buildSchemaContext(schemaData);
            const model = localStorage.getItem('graphiql:gemini-model') || 'gemini-2.0-flash';

            const prompt = `Based on this GraphQL schema, suggest 4 short (2-5 words each) natural language queries a user might want to start with. Return ONLY a JSON array of strings, no explanation.

${schemaContext}

Example output format: ["Get all users", "Find product by ID", "List recent orders", "Search customers"]`;

            const response = await fetch(
              `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  contents: [{ parts: [{ text: prompt }] }],
                  generationConfig: { responseMimeType: 'application/json' }
                })
              }
            );

            if (response.ok) {
              const data = await response.json();
              const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
              if (text) {
                const parsed = JSON.parse(text);
                if (Array.isArray(parsed) && parsed.length > 0) {
                  setSuggestions(parsed.slice(0, 4));
                }
              }
            }
          } catch (err) {
            console.error('Failed to fetch suggestions:', err);
          } finally {
            setLoadingSuggestions(false);
          }
        }, []);

        // Fetch initial suggestions on mount if we have an API key and no messages yet
        React.useEffect(() => {
          const apiKey = getGeminiApiKey();
          if (apiKey && messages.length === 0) {
            fetchInitialSuggestions();
          }
        }, []);

        // Scroll to bottom when messages update (contained within messages area)
        React.useEffect(() => {
          if (messagesContainerRef.current) {
            messagesContainerRef.current.scrollTop = messagesContainerRef.current.scrollHeight;
          }
        }, [messages]);

        // Listen for updates from the toolbar Analyse button
        React.useEffect(() => {
          const handleQueryGeneratorUpdate = () => {
            // Sync state from global window._queryGeneratorState
            if (window._queryGeneratorState) {
              setMessages(window._queryGeneratorState.messages || []);
              setSuggestions(window._queryGeneratorState.suggestions || ['Show all queries', 'List types', 'Help me build a query']);
              setIsLoading(window._queryGeneratorState.isLoading || false);
            }
          };

          window.addEventListener('queryGeneratorUpdate', handleQueryGeneratorUpdate);
          return () => {
            window.removeEventListener('queryGeneratorUpdate', handleQueryGeneratorUpdate);
          };
        }, []);

        // Close settings when clicking outside (but not when clicking the settings button)
        React.useEffect(() => {
          const handleClickOutside = (event) => {
            const isOutsidePopup = settingsRef.current && !settingsRef.current.contains(event.target);
            const isOutsideButton = settingsBtnRef.current && !settingsBtnRef.current.contains(event.target);
            if (isOutsidePopup && isOutsideButton) {
              setShowSettings(false);
            }
          };
          if (showSettings) {
            document.addEventListener('mousedown', handleClickOutside);
          }
          return () => document.removeEventListener('mousedown', handleClickOutside);
        }, [showSettings]);

        // Send message handler
        const sendMessage = async (messageText) => {
          const text = messageText || inputValue;
          if (!text.trim() || isLoading) return;

          const apiKey = getGeminiApiKey();
          if (!apiKey) {
            setError('Please configure your Gemini API key. Click the gear icon âš™ above.');
            return;
          }

          const userMessage = { role: 'user', content: text };
          setMessages(prev => [...prev, userMessage]);
          setInputValue('');
          setIsLoading(true);
          setError(null);

          try {
            const currentState = getEditorState();
            const response = await callGeminiAPI(
              text,
              currentState.query,
              currentState.variables,
              currentState.headers,
              messages
            );

            const aiMessage = {
              role: 'assistant',
              content: response.message,
              type: response.type,
              query: response.query,
              variables: response.variables,
              headers: response.headers,
              options: response.options,
              needsResults: response.needsResults || false,
              isNewQuery: response.isNewQuery || false,
              resultsSummary: response.resultsSummary || null
            };

            // Add original state and diffStatus to messages with changes
            const hasChanges = response.query || response.variables || response.headers;
            if ((response.type === 'query' || response.type === 'suggestion') && hasChanges) {
              aiMessage.originalQuery = currentState.query;
              aiMessage.originalVariables = currentState.variables;
              aiMessage.originalHeaders = currentState.headers;
              aiMessage.diffStatus = 'pending'; // 'pending', 'applied', 'dismissed', 'analyzing'
            }

            setMessages(prev => [...prev, aiMessage]);

            // Update suggestions from the response
            if (response.suggestions && Array.isArray(response.suggestions) && response.suggestions.length > 0) {
              setSuggestions(response.suggestions.slice(0, 4));
            }
          } catch (err) {
            setError(err.message);
            setMessages(prev => [...prev, {
              role: 'assistant',
              type: 'error',
              content: `Error: ${err.message}`
            }]);
          } finally {
            setIsLoading(false);
          }
        };

        // Handle option click from AI response
        const handleOptionClick = (option) => {
          sendMessage(option);
        };

        // Accept suggestion - takes message index (works for both pending and applied)
        const handleAccept = (msgIndex) => {
          setMessages(prev => prev.map((msg, idx) => {
            if (idx === msgIndex && (msg.diffStatus === 'pending' || msg.diffStatus === 'applied')) {
              setEditorState({
                query: msg.query,
                variables: msg.variables,
                headers: msg.headers
              });
              return { ...msg, diffStatus: 'applied' };
            }
            return msg;
          }));
        };

        // Accept and run - takes message index (works for both pending and applied)
        const handleAcceptAndRun = (msgIndex) => {
          setMessages(prev => prev.map((msg, idx) => {
            if (idx === msgIndex && (msg.diffStatus === 'pending' || msg.diffStatus === 'applied')) {
              setEditorState({
                query: msg.query,
                variables: msg.variables,
                headers: msg.headers
              });
              // Trigger query execution
              setTimeout(() => {
                const executeButton = document.querySelector('.graphiql-execute-button');
                if (executeButton) {
                  executeButton.click();
                }
              }, 150);
              return { ...msg, diffStatus: 'applied' };
            }
            return msg;
          }));
        };

        // Reject suggestion - takes message index
        const handleReject = (msgIndex) => {
          setMessages(prev => prev.map((msg, idx) => {
            if (idx === msgIndex && msg.diffStatus === 'pending') {
              return { ...msg, diffStatus: 'dismissed' };
            }
            return msg;
          }));
        };

        // Helper to get response from the response editor
        const getResponseFromEditor = () => {
          // Try to get from editorContext.responseEditor
          if (editorContext?.responseEditor) {
            const value = getEditorValue(editorContext.responseEditor);
            if (value) return value;
          }
          // Fallback: try to find the response panel in the DOM
          const responsePanel = document.querySelector('.graphiql-response .cm-content');
          if (responsePanel) {
            return responsePanel.textContent || '';
          }
          return null;
        };

        // Run query and analyze results - takes message index (works for both pending and applied)
        const handleRunAndAnalyze = async (msgIndex) => {
          const msg = messages[msgIndex];
          if (!msg || (msg.diffStatus !== 'pending' && msg.diffStatus !== 'applied')) return;

          // 1. Set status to analyzing
          setMessages(prev => prev.map((m, idx) =>
            idx === msgIndex ? { ...m, diffStatus: 'analyzing' } : m
          ));

          // 2. Apply the query to editor
          setEditorState({
            query: msg.query,
            variables: msg.variables,
            headers: msg.headers
          });

          try {
            // 3. Wait for editor to update with new query
            await new Promise(resolve => setTimeout(resolve, 300));

            // Verify the query was applied
            const currentEditorQuery = getEditorState().query;
            if (currentEditorQuery.trim() !== (msg.query || '').trim()) {
              // Try applying again
              setEditorState({
                query: msg.query,
                variables: msg.variables,
                headers: msg.headers
              });
              await new Promise(resolve => setTimeout(resolve, 300));
            }

            // 4. Click the execute button and wait for response
            const executeButton = document.querySelector('.graphiql-execute-button');
            if (!executeButton) {
              throw new Error('Execute button not found');
            }

            // Get current response to detect when it changes
            const oldResponse = getResponseFromEditor();

            // Click execute
            executeButton.click();

            // 4. Wait for the response (poll every 200ms, max 10 seconds)
            // Strategy: First wait for response to clear/change (loading started),
            // then wait for valid JSON result
            let results = null;
            const maxAttempts = 50;
            let attempts = 0;
            let loadingDetected = false;

            await new Promise((resolve, reject) => {
              const checkResponse = () => {
                attempts++;
                const newResponse = getResponseFromEditor();

                // First, detect if loading has started (response cleared or changed)
                if (!loadingDetected) {
                  if (!newResponse || newResponse !== oldResponse) {
                    loadingDetected = true;
                  }
                  // After 1 second, assume loading started even if response looks same
                  // (handles fast cached responses)
                  if (attempts >= 5) {
                    loadingDetected = true;
                  }
                }

                // Once loading detected, wait for valid JSON response
                if (loadingDetected && newResponse) {
                  try {
                    results = JSON.parse(newResponse);
                    resolve();
                    return;
                  } catch (e) {
                    // Not valid JSON yet, keep waiting
                  }
                }

                if (attempts >= maxAttempts) {
                  reject(new Error('Timeout waiting for query response'));
                  return;
                }

                setTimeout(checkResponse, 200);
              };
              setTimeout(checkResponse, 300); // Initial delay to let query start
            });

            if (!results) {
              throw new Error('Failed to get query results');
            }

            // 5. Add results feedback message (user) and analyzing status message (assistant)
            const resultsMessage = {
              role: 'user',
              type: 'results-feedback',
              content: `[User executed query and sent results for analysis]`,
              payload: {
                query: msg.query,
                variables: msg.variables,
                results: results
              }
            };

            const analyzingMessage = {
              role: 'assistant',
              type: 'analyzing-status',
              displayText: msg.resultsSummary || 'Analysing query results...',
              content: '' // This is just a status indicator, not sent to LLM
            };

            setMessages(prev => {
              const updated = prev.map((m, idx) =>
                idx === msgIndex ? { ...m, diffStatus: 'applied', resultsAnalyzed: true } : m
              );
              return [...updated, resultsMessage, analyzingMessage];
            });

            // 6. Send to Gemini for analysis
            setIsLoading(true);

            // Get current conversation for context (include the results message)
            const updatedMessages = [...messages];
            // Update the original message status
            const msgIndexInUpdated = updatedMessages.findIndex((m, i) => i === msgIndex);
            if (msgIndexInUpdated !== -1) {
              updatedMessages[msgIndexInUpdated] = { ...updatedMessages[msgIndexInUpdated], diffStatus: 'applied', resultsAnalyzed: true };
            }
            updatedMessages.push(resultsMessage);

            // Build analysis prompt with context
            const analysisPrompt = `The user clicked "Apply, Run & Analyse" to execute the suggested query and see the results.

Query that was executed:
\`\`\`graphql
${msg.query}
\`\`\`

${msg.variables && msg.variables !== '{}' ? `Variables used:\n\`\`\`json\n${msg.variables}\n\`\`\`\n\n` : ''}Results returned:
\`\`\`json
${JSON.stringify(results, null, 2)}
\`\`\`

Please analyse these results. Focus on:
- What the data shows (patterns, notable values, structure)
- Any errors or issues in the response

IMPORTANT: Do NOT suggest new queries or modifications unless:
1. There is an actual error in the response that needs fixing, OR
2. The user has explicitly asked for changes, improvements, or new queries in the conversation
If neither condition is met, provide analysis only - do not include a query in your response.`;

            const response = await callGeminiAPI(
              analysisPrompt,
              msg.query,
              msg.variables,
              msg.headers,
              updatedMessages
            );

            // Add AI analysis response
            const analysisMessage = {
              role: 'assistant',
              content: response.message,
              type: response.type || 'analysis',
              query: response.query,
              variables: response.variables,
              headers: response.headers,
              options: response.options,
              needsResults: response.needsResults || false,
              isNewQuery: response.isNewQuery || false,
              resultsSummary: response.resultsSummary || null
            };

            // Add diff status only if there are ACTUAL changes (not just the same query returned)
            const queryChanged = response.query && (response.query || '').trim() !== (msg.query || '').trim();
            const variablesChanged = response.variables && (response.variables || '').trim() !== (msg.variables || '').trim();
            const headersChanged = response.headers && (response.headers || '').trim() !== (msg.headers || '').trim();
            const hasActualChanges = queryChanged || variablesChanged || headersChanged;

            if ((response.type === 'query' || response.type === 'suggestion') && hasActualChanges) {
              analysisMessage.originalQuery = msg.query;
              analysisMessage.originalVariables = msg.variables;
              analysisMessage.originalHeaders = msg.headers;
              analysisMessage.diffStatus = 'pending';
            }

            // Remove the analyzing-status message and add the real response
            setMessages(prev => [...prev.filter(m => m.type !== 'analyzing-status'), analysisMessage]);

            // Update suggestions
            if (response.suggestions && Array.isArray(response.suggestions) && response.suggestions.length > 0) {
              setSuggestions(response.suggestions.slice(0, 4));
            }
          } catch (err) {
            setError(`Analysis failed: ${err.message}`);
            // Revert to pending on error and remove analyzing-status message
            setMessages(prev => prev
              .filter(m => m.type !== 'analyzing-status')
              .map((m, idx) => idx === msgIndex ? { ...m, diffStatus: 'pending' } : m)
            );
          } finally {
            setIsLoading(false);
          }
        };

        return React.createElement('div', {
          style: {
            padding: '0px',
            height: '100%',
            display: 'flex',
            flexDirection: 'column',
            gap: '16px',
            position: 'relative'
          }
        }, [
          // Header section with title and settings button
          React.createElement('div', {
            key: 'header',
            style: {
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'flex-start',
              position: 'relative'
            }
          }, [
            React.createElement('h3', {
              key: 'title',
              style: {
                margin: '0 0 4px 0',
                fontSize: '29px',
                fontWeight: 'bold'
              }
            }, 'Query Generator'),
            // Button container for clear and settings
            React.createElement('div', {
              key: 'button-container',
              style: { display: 'flex', alignItems: 'center', gap: '4px' }
            }, [
              // Clear chat button
              messages.length > 0 && React.createElement('button', {
                key: 'clear-btn',
                onClick: () => {
                  setMessages([]);
                  window._queryGeneratorState.messages = [];
                  localStorage.removeItem('graphiql:chat-messages');
                  setSuggestions(['Show all queries', 'List types', 'Help me build a query']);
                },
                title: 'Clear chat history',
                type: 'button',
                style: {
                  background: 'none',
                  border: 'none',
                  cursor: 'pointer',
                  padding: '8px',
                  borderRadius: '4px',
                  color: 'hsla(var(--color-neutral), var(--alpha-secondary))',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center'
                }
              }, React.createElement('svg', {
                width: '18',
                height: '18',
                viewBox: '0 0 24 24',
                fill: 'none',
                stroke: 'currentColor',
                strokeWidth: '2',
                strokeLinecap: 'round',
                strokeLinejoin: 'round'
              }, [
                React.createElement('polyline', { key: 'p1', points: '3 6 5 6 21 6' }),
                React.createElement('path', { key: 'p2', d: 'M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2' })
              ])),
              // Settings gear button
              React.createElement('button', {
                key: 'settings-btn',
                ref: settingsBtnRef,
                onClick: () => setShowSettings(!showSettings),
                title: 'Settings',
                type: 'button',
                style: {
                  background: 'none',
                  border: 'none',
                  cursor: 'pointer',
                  padding: '8px',
                  borderRadius: '4px',
                  color: 'hsla(var(--color-neutral), var(--alpha-secondary))',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center'
                }
              }, React.createElement('svg', {
                width: '20',
                height: '20',
                viewBox: '0 0 24 24',
                fill: 'currentColor'
              }, React.createElement('path', {
                d: 'M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58a.49.49 0 00.12-.61l-1.92-3.32a.488.488 0 00-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 00-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58a.49.49 0 00-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z'
              }))),
              // Settings popup is now rendered as a centered modal (see below)
              null
            ])
          ]),
          // Description
          React.createElement('p', {
            key: 'description',
            className: 'graphiql-markdown-description',
            style: {
              margin: '0 0 4px 0',
              color: 'rgba(59, 75, 104, 0.76)'
            }
          }, 'Describe what you want to query in natural language'),

          // Messages Area
          React.createElement('div', {
            key: 'messages',
            ref: messagesContainerRef,
            style: {
              flex: 1,
              overflow: 'auto',
              padding: '0',
              display: 'flex',
              flexDirection: 'column'
            }
          }, [
            // Welcome message if no messages
            messages.length === 0 && React.createElement('div', {
              key: 'welcome',
              style: {
                textAlign: 'center',
                padding: '48px 24px',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                flex: 1
              }
            }, [
              // GraphQL-style decorative icon
              React.createElement('div', {
                key: 'welcome-icon',
                style: {
                  width: '48px',
                  height: '48px',
                  marginBottom: '16px',
                  borderRadius: '12px',
                  background: 'hsla(var(--color-primary), 0.1)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center'
                }
              }, React.createElement('svg', {
                width: '24',
                height: '24',
                viewBox: '0 0 24 24',
                fill: 'hsl(var(--color-primary))'
              }, React.createElement('path', {
                d: 'M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z'
              }))),
              React.createElement('p', {
                key: 'welcome-text',
                style: {
                  margin: '0 0 8px 0',
                  fontWeight: '600',
                  fontSize: '15px',
                  color: 'hsla(var(--color-neutral), 1)'
                }
              }, 'Start a conversation'),
              React.createElement('p', {
                key: 'welcome-desc',
                className: 'graphiql-markdown-description',
                style: {
                  margin: 0,
                  fontSize: '13px',
                  color: 'rgba(59, 75, 104, 0.76)',
                  maxWidth: '240px'
                }
              }, 'Type a message below to generate GraphQL queries using natural language')
            ]),

            // Message list
            ...messages.map((msg, idx) => {
              // Show diff for any message that has changes (query, variables, or headers) and diffStatus
              const hasChangesWithDiff = (msg.query || msg.variables || msg.headers) && msg.diffStatus;

              return React.createElement(MessageComponent, {
                key: idx,
                message: msg,
                onOptionClick: handleOptionClick,
                showDiff: hasChangesWithDiff,
                diffStatus: msg.diffStatus,
                onAccept: () => handleAccept(idx),
                onReject: () => handleReject(idx),
                onAcceptAndRun: () => handleAcceptAndRun(idx),
                onRunAndAnalyze: () => handleRunAndAnalyze(idx)
              });
            }),

            // Loading indicator
            isLoading && React.createElement('div', {
              key: 'loading',
              style: {
                display: 'flex',
                justifyContent: 'flex-start',
                marginBottom: '8px'
              }
            }, React.createElement('div', {
              style: {
                padding: '10px 14px',
                borderRadius: '12px',
                background: 'var(--color-base-bg, #f1f3f5)',
                color: 'var(--color-alpha-secondary, #586069)',
                fontSize: '13px'
              }
            }, 'â— â— â—')),

          ]),

          // Error display
          error && React.createElement('div', {
            key: 'error',
            style: {
              padding: '10px 16px',
              background: '#ffeaea',
              color: '#d73a49',
              fontSize: '12px',
              borderTop: '1px solid #ffc4c4'
            }
          }, [
            React.createElement('span', { key: 'icon' }, 'âš  '),
            error
          ]),

          // Input Area with suggestions
          React.createElement('div', {
            key: 'input-area',
            style: {
              padding: '12px 16px',
              borderTop: '1px solid var(--color-border, #e1e4e8)',
              display: 'flex',
              flexDirection: 'column',
              gap: '10px'
            }
          }, [
            // Quick suggestions (dynamically generated)
            React.createElement('div', {
              key: 'quick-suggestions',
              style: {
                display: 'flex',
                flexWrap: 'wrap',
                gap: '6px',
                alignItems: 'center'
              }
            }, [
              // Loading indicator for suggestions
              loadingSuggestions && React.createElement('span', {
                key: 'loading-suggestions',
                style: {
                  fontSize: '11px',
                  color: 'var(--color-alpha-secondary, #586069)',
                  fontStyle: 'italic'
                }
              }, 'Loading suggestions...'),
              // Suggestion buttons
              ...(!loadingSuggestions ? suggestions.map((suggestion, idx) =>
                React.createElement('button', {
                  key: idx,
                  type: 'button',
                  onClick: (e) => { e.preventDefault(); sendMessage(suggestion); },
                  disabled: isLoading,
                  style: {
                    padding: '5px 10px',
                  background: '#e3f2fd',
                  border: '1px solid #bbdefb',
                  borderRadius: '12px',
                  fontSize: '11px',
                  cursor: isLoading ? 'not-allowed' : 'pointer',
                  color: '#1565c0',
                  transition: 'all 0.15s ease',
                  opacity: isLoading ? 0.5 : 1
                },
                onMouseEnter: (e) => {
                  if (!isLoading) {
                    e.target.style.background = '#1976d2';
                    e.target.style.color = 'white';
                    e.target.style.borderColor = '#1976d2';
                  }
                },
                onMouseLeave: (e) => {
                  e.target.style.background = '#e3f2fd';
                  e.target.style.color = '#1565c0';
                  e.target.style.borderColor = '#bbdefb';
                }
              }, suggestion)
              ) : [])
            ]),
            // Input row
            React.createElement('div', {
              key: 'input-row',
              style: {
                display: 'flex',
                gap: '8px'
              }
            }, [
              React.createElement('input', {
                key: 'input',
                type: 'text',
                value: inputValue,
                onChange: (e) => setInputValue(e.target.value),
                onKeyDown: (e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                  }
                },
                placeholder: 'Describe your query...',
                disabled: isLoading,
                style: {
                  flex: 1,
                  padding: '8px 12px',
                  border: '1px solid var(--color-border, #d1d5da)',
                  borderRadius: '6px',
                  fontSize: '13px',
                  background: 'var(--color-base-bg, white)',
                  color: 'var(--color-base)'
                }
              }),
              React.createElement('button', {
                key: 'send-btn',
                type: 'button',
                onClick: (e) => { e.preventDefault(); sendMessage(); },
                disabled: isLoading || !inputValue.trim(),
                style: {
                  padding: '8px 14px',
                  backgroundColor: isLoading || !inputValue.trim() ? 'var(--color-alpha-tertiary, #ccc)' : 'hsl(var(--color-primary))',
                  color: 'white',
                  border: 'none',
                  borderRadius: '6px',
                  cursor: isLoading || !inputValue.trim() ? 'not-allowed' : 'pointer',
                  fontSize: '13px',
                  fontWeight: '500',
                  transition: 'background-color 0.15s ease'
                }
              }, isLoading ? '...' : 'Send')
            ])
          ]),

          // Settings Modal (centered dialog with backdrop - matches GraphiQL native style)
          showSettings && React.createElement('div', {
            key: 'settings-backdrop',
            onClick: (e) => {
              if (e.target === e.currentTarget) setShowSettings(false);
            },
            style: {
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(59, 75, 104, 0.15)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 100
            }
          }, React.createElement('div', {
            key: 'settings-dialog',
            ref: settingsRef,
            className: 'graphiql-dialog',
            onClick: (e) => e.stopPropagation(),
            style: { pointerEvents: 'auto' }
          }, React.createElement(SettingsPopupContent, { onClose: () => setShowSettings(false) })))
        ]);
      };

      // Query Generator Plugin Object
      const queryGeneratorPlugin = {
        title: 'Query Generator',
        icon: () => React.createElement('svg', {
          width: '16',
          height: '16',
          viewBox: '0 0 24 24',
          fill: 'none',
          stroke: 'currentColor',
          strokeWidth: '2',
          strokeLinecap: 'round',
          strokeLinejoin: 'round'
        }, [
          // Rounded square with open top-right corner (cut off at 50%)
          React.createElement('path', {
            key: 'box',
            d: 'M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V12',
            fill: 'none'
          }),
          // Large sparkle (center-right, crevices curve inward)
          React.createElement('path', {
            key: 'sparkle1',
            d: 'M16.6 0.3 Q17.2 7.5 24.4 8.1 Q17.2 8.7 16.6 15.9 Q16 8.7 8.8 8.1 Q16 7.5 16.6 0.3 Z',
            fill: 'currentColor',
            stroke: 'none'
          }),
          // Small sparkle (bottom-left inside, moved up 2px and right 2px)
          React.createElement('path', {
            key: 'sparkle2',
            d: 'M9 13l.75-1.5.75 1.5 1.5.75-1.5.75-.75 1.5-.75-1.5-1.5-.75z',
            fill: 'currentColor',
            stroke: 'none'
          }),
          // Tiny sparkle (top-right outside, moved up 1px)
          React.createElement('path', {
            key: 'sparkle3',
            d: 'M20 3l.5-1 .5 1 1 .5-1 .5-.5 1-.5-1-1-.5z',
            fill: 'currentColor',
            stroke: 'none'
          })
        ]),
        content: () => QueryGeneratorPanel()
      };

      const params = Object.fromEntries(new URLSearchParams(location.search));
      const { query, variables, operationName, ...rest } = params;
      const fetchURL = '?' + new URLSearchParams(rest).toString();

      const fetcher = createGraphiQLFetcher({
        url: fetchURL
      });
      const plugins = [HISTORY_PLUGIN, explorerPlugin(), sdlDownloadPlugin, schemaVisualizerPlugin, queryGeneratorPlugin];

      // Store the default query so we can use it in the storage wrapper
      const defaultQueryValue = "DEFAULT_QUERY";

      // Custom storage that replaces empty queries with defaultQuery
      const customStorage = {
        ...localStorage,
        getItem(key) {
          const value = localStorage.getItem(key);

          // Handle GraphiQL tab state - replace empty query with default
          if (key === 'graphiql:tabState' && value) {
            try {
              const tabState = JSON.parse(value);
              if (tabState && tabState.tabs && Array.isArray(tabState.tabs)) {
                const activeIndex = tabState.activeTabIndex || 0;
                const activeTab = tabState.tabs[activeIndex];

                // If the active tab's query is empty or whitespace, replace it with defaultQuery
                if (activeTab && (!activeTab.query || activeTab.query.trim() === '')) {
                  // Check if the default query already exists in ANY tab
                  const defaultExistsInAnyTab = tabState.tabs.some(tab =>
                    tab.query && tab.query.trim() === defaultQueryValue.trim()
                  );

                  // Only update if it's not already the default AND doesn't exist in any other tab
                  if (activeTab.query !== defaultQueryValue && !defaultExistsInAnyTab) {
                    activeTab.query = defaultQueryValue;
                    const updatedValue = JSON.stringify(tabState);
                    localStorage.setItem(key, updatedValue);
                    return updatedValue;
                  }
                }
              }
            } catch (e) {
              // If parsing fails, just return the value as-is
              return value;
            }
          }

          return value;
        },
        setItem(key, value) {
          return localStorage.setItem(key, value);
        },
        removeItem(key) {
          return localStorage.removeItem(key);
        }
      };

      // Analyse Button Component for the toolbar
      const AnalyseButton = () => {
        const editorContext = useEditorContext();
        const pluginContext = usePluginContext();
        const [isAnalysing, setIsAnalysing] = React.useState(false);
        const [popup, setPopup] = React.useState(null); // { message: string }

        // Function to switch to Query Generator tab
        const switchToQueryGenerator = () => {
          // Use plugin context to set visible plugin directly
          if (pluginContext?.setVisiblePlugin) {
            // Find the Query Generator plugin from the plugins list
            const qgPlugin = pluginContext.plugins?.find(p => p.title === 'Query Generator');
            if (qgPlugin && pluginContext.visiblePlugin !== qgPlugin) {
              pluginContext.setVisiblePlugin(qgPlugin);
              return;
            }
          }

          // Fallback: click the sidebar button directly
          const allButtons = document.querySelectorAll('button');
          for (const btn of allButtons) {
            const ariaLabel = btn.getAttribute('aria-label');
            if (ariaLabel === 'Query Generator') {
              btn.click();
              return;
            }
          }
        };

        const handleAnalyse = async () => {
          if (isAnalysing) return;

          // Get current query from editor
          const query = editorContext?.queryEditor?.getValue?.() ||
                       editorContext?.queryEditor?.state?.doc?.toString?.() || '';

          // Get variables
          const variables = editorContext?.variableEditor?.getValue?.() ||
                           editorContext?.variableEditor?.state?.doc?.toString?.() || '{}';

          // Get response from response editor
          const response = editorContext?.responseEditor?.getValue?.() ||
                          editorContext?.responseEditor?.state?.doc?.toString?.() || '';

          if (!query.trim()) {
            setPopup({ message: 'No query to analyse' });
            return;
          }

          if (!response.trim()) {
            setPopup({ message: 'No response to analyse. Run the query first.' });
            return;
          }

          const apiKey = getGeminiApiKey();
          if (!apiKey) {
            setPopup({ message: 'Please configure your Gemini API key in the Query Generator settings first.' });
            return;
          }

          // Switch to Query Generator tab
          switchToQueryGenerator();

          setIsAnalysing(true);
          window._queryGeneratorState.isLoading = true;
          window.dispatchEvent(new CustomEvent('queryGeneratorUpdate'));

          try {
            // Parse response if possible
            let parsedResponse;
            try {
              parsedResponse = JSON.parse(response);
            } catch (e) {
              parsedResponse = response;
            }

            // Get existing conversation from Query Generator
            const existingMessages = window._queryGeneratorState?.messages || [];

            // Create the results feedback message (user) and analyzing status message (assistant)
            const userMessage = {
              role: 'user',
              type: 'results-feedback',
              content: `[User executed query and sent results for analysis]`,
              payload: {
                query: query,
                variables: variables,
                results: parsedResponse
              }
            };

            const analyzingMessage = {
              role: 'assistant',
              type: 'analyzing-status',
              displayText: 'Analysing current query results...',
              content: ''
            };

            // Add to conversation
            const updatedMessages = [...existingMessages, userMessage, analyzingMessage];
            window._queryGeneratorState.messages = updatedMessages;

            // Trigger re-render in Query Generator if it's open
            window.dispatchEvent(new CustomEvent('queryGeneratorAnalyse', {
              detail: { query, variables, response: parsedResponse, userMessage, analyzingMessage }
            }));

            // Call Gemini API with context about being an analysis assistant
            const analysisPrompt = `The user clicked the "Analyse" button in GraphiQL to analyse the current query and its results.

Query that was executed:
\`\`\`graphql
${query}
\`\`\`

Variables used:
\`\`\`json
${variables}
\`\`\`

Results returned:
\`\`\`json
${JSON.stringify(parsedResponse, null, 2)}
\`\`\`

Please analyse these results. Focus on:
- What the data shows (patterns, notable values, structure)
- Any errors or issues in the response

IMPORTANT: Do NOT suggest new queries or modifications unless:
1. There is an actual error in the response that needs fixing, OR
2. The user has explicitly asked for changes, improvements, or new queries in the conversation
If neither condition is met, provide analysis only - do not include a query in your response.`;

            const aiResponse = await callGeminiAPI(
              analysisPrompt,
              query,
              variables,
              '{}',
              updatedMessages
            );

            // Add AI response to conversation
            const aiMessage = {
              role: 'assistant',
              content: aiResponse.message,
              type: aiResponse.type || 'analysis',
              query: aiResponse.query,
              variables: aiResponse.variables,
              headers: aiResponse.headers,
              options: aiResponse.options,
              needsResults: aiResponse.needsResults || false,
              isNewQuery: aiResponse.isNewQuery || false,
              resultsSummary: aiResponse.resultsSummary || null
            };

            // Check for actual changes
            const queryChanged = aiResponse.query && (aiResponse.query || '').trim() !== (query || '').trim();
            const variablesChanged = aiResponse.variables && (aiResponse.variables || '').trim() !== (variables || '').trim();
            if ((aiResponse.type === 'query' || aiResponse.type === 'suggestion') && (queryChanged || variablesChanged)) {
              aiMessage.originalQuery = query;
              aiMessage.originalVariables = variables;
              aiMessage.originalHeaders = '{}';
              aiMessage.diffStatus = 'pending';
            }

            // Remove analyzing-status message and add the real response
            window._queryGeneratorState.messages = [...updatedMessages.filter(m => m.type !== 'analyzing-status'), aiMessage];

            // Update suggestions if provided
            if (aiResponse.suggestions && Array.isArray(aiResponse.suggestions)) {
              window._queryGeneratorState.suggestions = aiResponse.suggestions.slice(0, 4);
            }

            // Trigger update
            window._queryGeneratorState.isLoading = false;
            window.dispatchEvent(new CustomEvent('queryGeneratorUpdate'));

          } catch (err) {
            console.error('Analysis failed:', err);
            window._queryGeneratorState.isLoading = false;
            window.dispatchEvent(new CustomEvent('queryGeneratorUpdate'));
            setPopup({ message: `Analysis failed: ${err.message}` });
          } finally {
            setIsAnalysing(false);
          }
        };

        return React.createElement(React.Fragment, null, [
          // Popup for errors/messages
          popup && React.createElement('div', {
            key: 'popup',
            style: {
              position: 'fixed',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              background: 'white',
              padding: '20px 24px',
              borderRadius: '8px',
              boxShadow: '0 4px 20px rgba(0,0,0,0.15)',
              zIndex: 10000,
              maxWidth: '320px',
              textAlign: 'center'
            }
          }, [
            React.createElement('p', {
              key: 'message',
              style: { margin: '0 0 16px 0', color: '#24292e', fontSize: '14px', lineHeight: '1.5' }
            }, popup.message),
            React.createElement('button', {
              key: 'close',
              onClick: () => setPopup(null),
              style: {
                padding: '8px 20px',
                background: '#e3f2fd',
                color: '#1565c0',
                border: 'none',
                borderRadius: '6px',
                fontSize: '13px',
                cursor: 'pointer',
                fontWeight: 500
              }
            }, 'OK')
          ]),
          // Backdrop for popup
          popup && React.createElement('div', {
            key: 'backdrop',
            onClick: () => setPopup(null),
            style: {
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0,0,0,0.3)',
              zIndex: 9999
            }
          }),
          // The Analyse button using ToolbarButton for proper tooltip styling
          React.createElement(ToolbarButton, {
            key: 'analyse-btn',
            label: 'Analyse with AI',
            onClick: handleAnalyse,
            disabled: isAnalysing
          }, isAnalysing ?
            React.createElement('div', {
              style: {
                width: '18px',
                height: '18px',
                border: '2px solid hsla(var(--color-neutral), 0.2)',
                borderTopColor: 'hsla(var(--color-neutral), var(--alpha-tertiary, 0.4))',
                borderRadius: '50%',
                animation: 'spin 0.8s linear infinite'
              }
            }) :
            React.createElement('svg', {
              width: '22',
              height: '22',
              viewBox: '0 0 24 24',
              fill: 'none',
              style: { color: 'hsla(var(--color-neutral), var(--alpha-tertiary, 0.4))' }
            }, [
              // Rounded square with open top-right corner (cut off at 50%)
              React.createElement('path', {
                key: 'box',
                d: 'M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V12',
                fill: 'none',
                stroke: 'currentColor',
                strokeWidth: '2',
                strokeLinecap: 'round',
                strokeLinejoin: 'round'
              }),
              // Large sparkle (center-right, crevices curve inward)
              React.createElement('path', {
                key: 'sparkle1',
                d: 'M16.6 0.3 Q17.2 7.5 24.4 8.1 Q17.2 8.7 16.6 15.9 Q16 8.7 8.8 8.1 Q16 7.5 16.6 0.3 Z',
                fill: 'currentColor'
              }),
              // Small sparkle (bottom-left inside, moved up 2px and right 2px)
              React.createElement('path', {
                key: 'sparkle2',
                d: 'M9 13l.75-1.5.75 1.5 1.5.75-1.5.75-.75 1.5-.75-1.5-1.5-.75z',
                fill: 'currentColor'
              }),
              // Tiny sparkle (top-right outside, moved up 1px)
              React.createElement('path', {
                key: 'sparkle3',
                d: 'M20 3l.5-1 .5 1 1 .5-1 .5-.5 1-.5-1-1-.5z',
                fill: 'currentColor'
              })
            ])
          )
        ]);
      };

      function App() {
        return React.createElement(GraphiQL, {
          fetcher,
          plugins,
          defaultEditorToolsVisibility: false,
          isHeadersEditorEnabled: true,
          defaultQuery: defaultQueryValue,
          storage: customStorage
        },
          // Use GraphiQL.Toolbar with render prop to add custom button alongside defaults
          React.createElement(GraphiQL.Toolbar, null,
            ({ copy, merge, prettify }) => React.createElement(React.Fragment, null,
              copy,
              merge,
              prettify,
              React.createElement(AnalyseButton, { key: 'analyse-btn' })
            )
          )
        );
      }

      const container = document.getElementById('graphiql');
      const root = ReactDOM.createRoot(container);
      root.render(React.createElement(App));
    </script>
  </head>
  <body>
    <div id="graphiql">
      <div class="loading">Loadingâ€¦</div>
    </div>
  </body>
</html>
